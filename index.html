<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
      A Post-Mortem On Ambient: A Rust/WebAssembly Runtime for Cross-Platform
      Multiplayer Games
    </title>
    <link rel="stylesheet" href="/node_modules/reveal.js/dist/reveal.css" />
    <link
      rel="stylesheet"
      href="/node_modules/reveal.js/dist/theme/serif.css"
    />
    <link
      rel="stylesheet"
      href="/node_modules/reveal.js/plugin/highlight/zenburn.css"
    />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!-- Title slide with main heading and subtitle -->
        <section>
          <h2>A Post-Mortem On Ambient</h2>
          <h4>
            What <em>Was</em> A Rust/WebAssembly Runtime for Cross-Platform
            Multiplayer Games
          </h4>
          <p>Mithun Hunsur (<a href="https://philpax.me">philpax.me</a>)</p>
          <aside class="notes">
            G'day everyone! It may be the second quarter of the year, but I'm
            still in a reflective mood. I'm here today to talk to you about
            Ambient, the open-source cross-platform multiplayer game runtime
            that I worked on from early 2023 to late 2023. I'll tell you about
            the project, what we did well, and what went wrong.
          </aside>
        </section>

        <!-- Speaker introduction slide with contact info and projects -->
        <section>
          <h2>Who am I?</h2>
          <h3>Mithun Hunsur</h3>
          <div style="text-align: left">
            <p><em>currently</em> not doing Rust professionally 😭</p>
            <p><em>formerly</em> <strong>Senior Engineer</strong> @ Ambient</p>
            <p>
              <em>formerly</em> <strong>Multiplayer Programmer</strong> @
              Avalanche Studios
            </p>
            <p>
              <em>formerly</em> <strong>Co-Lead Developer</strong> @ Just Cause
              2 Multiplayer
            </p>
            <p><small>and a lot of other things</small></p>
          </div>
          <aside class="notes">
            First off, let me introduce myself. My name's Mithun, but I go by
            Philpax online. I'm all over the shop, but my home base is in games,
            where I've been working on multiplayer projects for over a decade.
            During 2022 to late 2024, I worked at Ambient, also known as Dims
            and Braindump, to explore new ways of creating multiplayer games to
            enable both local and global collaboration. Before that, I worked at
            Avalanche Studios as a triple-A gamedev, and well before that, I
            worked on a volunteer project to make Just Cause 2 a massively
            multiplayer game with scripting. In my free time, I work on all
            kinds of things, including open-source AI, projects perpetually on
            the verge of release, and more.
          </aside>
        </section>

        <!-- Introduction to Ambient slide -->
        <section>
          <h1>What was Ambient?</h1>
          <aside class="notes">
            So, what was the Ambient runtime? Multiplayer game development is
            challenging. Most of the existing solutions were lacking in some
            way: they didn't support multiplayer, they weren't cross-platform,
            or they limited the developer's creativity. We wanted to solve this
            problem and make it easy for people to build multiplayer games.
          </aside>
        </section>

        <!-- Video background slide showing Dims project -->
        <section
          data-background-video="media/dims.mp4"
          data-background-video-loop
          data-background-video-muted
        >
          <aside class="notes">
            Of course, that took a few tries. What you're seeing here was our
            first attempt to solve multiplayer game development. This is Dims, a
            collaborative low-code game development platform, also built in
            Rust. You can build worlds, hang out together, and share them with
            others. Worlds aren't games, though. To bring them to life, we
            decided to let you script your games with WebAssembly. And then we
            realised it was becoming something else entirely.
          </aside>
        </section>

        <!-- Ambient logo and feature list slide with two columns -->
        <section>
          <div style="text-align: center">
            <img
              src="media/logo.svg"
              alt="Ambient"
              style="height: 140px; margin: 0 auto; margin-top: 60px"
            />
          </div>
          <div style="display: flex; align-items: center">
            <div
              style="flex: 0 0 50%; display: flex; justify-content: flex-end"
            >
              <ul
                style="
                  list-style: none;
                  text-align: right;
                  font-size: 1.2em;
                  margin: 0;
                  margin-right: 20px;
                  padding: 0;
                "
              >
                <li>Open-source</li>
                <li>Multiplayer-first</li>
                <li>Cross-platform</li>
                <li>WebAssembly</li>
                <li>Web support</li>
                <li>Package-centric workflow</li>
              </ul>
            </div>
            <div style="flex: 0 0 50%">
              <img
                src="media/screenshot.png"
                style="width: 100%; height: auto"
              />
            </div>
          </div>
          <aside class="notes">
            We took the core engine of Dims, cleaned it up, and open-sourced it
            to create Ambient. Once that was done, scaled up the scripting, we
            then built a package ecosystem, ported it to the web, and built a
            cloud platform around it. That is to say: Ambient was a modern
            open-source multiplayer-first cross-platform game runtime with
            WebAssembly-based scripting, web support, and a package-centric
            workflow. All of this was backed by a cloud platform, the "Ambient
            Platform", that allows users to build, play and publish packages and
            games.
          </aside>
        </section>

        <!-- Slide showing all components built in Rust with Rustacean overlay -->
        <section>
          <div
            style="
              position: relative;
              display: flex;
              flex-direction: column;
              justify-content: center;
              align-items: center;
              height: 100%;
            "
          >
            <ul
              style="
                list-style: none;
                text-align: center;
                padding: 0;
                margin: 0;
                font-size: 1.5em;
                line-height: 1.5;
              "
            >
              <li>Game server</li>
              <li>Desktop client</li>
              <li>Web client</li>
              <li>Scripting</li>
              <li>Build automation</li>
              <li>Cloud services</li>
              <li>Website</li>
            </ul>
            <div
              class="fragment"
              style="
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10;
              "
            >
              <img
                src="media/rustacean.png"
                style="width: 60%; opacity: 0.6"
                alt="Rustacean"
              />
            </div>
          </div>
          <aside class="notes">
            And of course, all of this was written in Rust. And I mean *all* of
            it. The game server? The desktop client? The web client? The
            scripting? The build automation? The cloud services? The website?
            *click* The crab comes for us all. The primary focus today will be
            on the game engine, but I'll briefly touch upon the website as well.
          </aside>
        </section>
        <!-- Slide explaining why Rust was chosen -->
        <section>
          <h2>Why Rust?</h2>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>Performance</li>
              <li>Modern features</li>
              <li>Cross-platform code</li>
              <li>General-purpose use</li>
              <li>Code sharing</li>
            </ul>
          </div>
          <aside class="notes">
            A game engine requires performance, and the typical answer is C++.
            But we chose Rust. We wanted a safe and performant language with
            modern conveniences. We wanted the tooling: cargo, clippy, rustfmt
            We wanted native support for concurrency and parallelism. We wanted
            a rich, reliable package ecosystem. We wanted to confidently
            refactor code with ease. And we wanted a strong type system,
            including enums, traits, and more, all backed by the borrow checker.
            Of course, these also make it much easier to write cross-platform
            code, especially with Rust crates: the vast majority of our code was
            the same between Windows, macOS and Linux. Rust is also a fantastic
            general-purpose language, which is why we used it for everything
            else. This allowed us to easily share code and do more with less.
          </aside>
        </section>

        <!-- Two-column slide listing engine features -->
        <section>
          <div
            style="
              display: flex;
              justify-content: space-between;
              height: 100%;
              align-items: center;
            "
          >
            <div style="flex: 1">
              <div
                style="
                  display: flex;
                  flex-direction: column;
                  gap: 0.6em;
                  padding: 0;
                  margin: 0;
                  font-size: 1.4em;
                  text-align: center;
                  line-height: 1.2;
                "
              >
                <div>ECS</div>
                <div>Physically-based rendering</div>
                <div>Asset pipeline</div>
                <div>WASM scripting</div>
                <div>Dynamically-loaded packages</div>
              </div>
            </div>
            <div style="flex: 1">
              <div
                style="
                  display: flex;
                  flex-direction: column;
                  gap: 0.6em;
                  padding: 0;
                  margin: 0;
                  font-size: 1.4em;
                  text-align: center;
                  line-height: 1.2;
                "
              >
                <div>Spatial audio</div>
                <div>Character animation</div>
                <div>PhysX</div>
                <div>React-like UI</div>
                <div>Web support</div>
              </div>
            </div>
          </div>
          <aside class="notes">
            Now, let's talk features. We were a batteries-included runtime, so
            we made sure our engine had everything you might need to build a
            game, as you can see here. The most innovative items on this list
            are the packages, WASM scripting, and web support. Let's start with
            the packages.
          </aside>
        </section>

        <!-- Slide about packages with TOML example -->
        <section>
          <h2 style="font-size: 1.8em">
            Packages: Rust crates, but for gamedev?
          </h2>
          <div style="display: flex; align-items: center; height: 80%">
            <div style="flex: 0 0 45%">
              <p>What can you do when you make your ECS dynamic?</p>
              <p>What does the ultimate moddable game platform look like?</p>
            </div>
            <div style="flex: 0 0 55%">
              <pre><code style="font-size: 0.7em; white-space: pre-wrap; line-height: 1.2em;" class="language-toml" data-trim data-noescape>
[package]
id = "jkr622pbesmaco76bjc6116v4t41ajh"
name = "Screen Ray"

[messages.Input.fields]
ray_origin = "Vec3"
ray_dir = "Vec3"
spawn = "Bool"

[components.player_cube_ref]
name = "Player Cube Ref"
description = "Attached to the player; references the preview cube the player is controlling."
type = "EntityId"
attributes = ["Networked", "Debuggable"]

[dependencies]
orbit_camera = {id = "tijz7x6fimbgu24sbbtp4n1lhfxbgb1p", version = "0.3.2"}
              </code></pre>
            </div>
          </div>
          <aside class="notes">
            Like many modern game engines, we used an entity component system —
            an ECS — in which entities have components, which are pieces of
            data, and these entities and their components are acted upon by
            systems. However, we wanted to go a step further. I grew up with
            Garry's Mod, where you could load code and assets at runtime to
            extend the game experience. We wanted to build a modern take, which
            led us to our runtime-loadable packages, inspired heavily by Rust
            crates. These can add new components, bring in new assets, load new
            WASM modules, and even message each other. And of course, they can
            depend on other packages.
          </aside>
        </section>

        <!-- Demo announcement slide -->
        <section>
          <h1 class="r-fit-text">Demo time!</h1>
          <h2>Tangent</h2>
          <h3>a simple 3D multiplayer game</h3>
          <aside class="notes">
            Unfortunately, as our web services have gone down, I can't show you
            the full Ambient experience; this means no web client, no cloud
            packages, and no modding. However, I can at least show you what the
            multiplayer experience is like with Tangent, a simple 3D multiplayer
            game where you control a protagonist that can run around, get into a
            hovercraft, and shoot at each other. I can also briefly take you
            through how packages are structured, and how scripting works.
          </aside>
        </section>

        <!-- Slide about using Rust as scripting language with code example -->
        <section>
          <h2 style="font-size: 1.8em">Using Rust as a Scripting Language</h2>
          <div style="display: flex; align-items: center; height: 80%">
            <div style="flex: 0 0 50%; font-size: 0.8em; text-align: right">
              <p>Easy to share code with the host</p>
              <p>Still complex, even with API hiding complexity</p>
              <p>Compile-times are not the fastest</p>
              <p>A bit scary to new users</p>
              <p>A higher-level Rust would win. Grain?</p>
            </div>
            <div style="flex: 0 0 50%">
              <pre><code style="font-size: 0.55em; white-space: pre-wrap; line-height: 1.2em;" class="language-rust" data-trim data-noescape>
#[main]
pub fn main() {
    Entity::new()
        .with(quad(), ())
        .with(scale(), Vec3::ONE * 10.)
        .with(color(), vec4(1., 0., 0., 1.))
        .with(plane_collider(), ())
        .spawn();

    Entity::new()
        .with_merge(Sphere::suggested())
        .with(sphere_collider(), 0.5)
        .with(translation(), vec3(5., 5., 1.))
        .spawn();

    spawn_query(is_player()).bind(move |players| {
        for (id, _) in players {
            entity::add_components(
                id,
                Entity::new()
                    .with_merge(ThirdPersonController::suggested())
                    .with(camera_distance(), 0.0),
            );
        }
    });
}
              </code></pre>
            </div>
          </div>
          <aside class="notes">
            As you might have noticed in the demo, we used Rust as our scripting
            language. This is made possible through WebAssembly - more on that
            later. We liked using Rust for scripting, and it let us share a lot
            of code, which was fantastic for letting us change things on the
            host and the guest at the same time. However, the language is still
            somewhat complex, despite our attempts to hide it under the API. The
            compile times were OK, but not fantastic: game developers appreciate
            fast iteration times, and Rust doesn't always provide that. We also
            had a concern that the use of Rust might scare off potential users;
            we found that users were fine with it once they got used to it, but
            it was definitely a barrier to entry. I believe a slightly
            higher-level language would be better for this use case, but I'm not
            sure what that would look like. Perhaps Grain, which is a ML-like
            language targeting WebAssembly, would be a good fit.
          </aside>
        </section>

        <!-- Code generation slide showing data model in TOML -->
        <section>
          <h2>Extreme Code Generation</h2>
          <h3 style="margin-bottom: 0">Data model</h3>
          <div style="display: flex; align-items: center; height: 80%">
            <div style="flex: 0 0 40%">
              <p>Package definitions in TOML</p>
              <p>Definitions need to be used in code</p>
            </div>
            <div style="flex: 0 0 60%">
              <pre><code style="font-size: 0.45em; white-space: pre-wrap; line-height: 1.2em;" class="language-toml" data-trim data-noescape>
[package]
name = "Camera"
description = "Camera matrices, types, parameters, and more."
content = { type = "Asset", schema = true }
version = "0.3.2-dev"
ambient_version = "0.3.2-nightly-2023-12-21"

[components.active_camera]
type = "F32"
name = "Active camera"
description = """
The camera with the highest `active_camera` value will be used for rendering. Cameras are also filtered by the `user_id`.
If there's no `user_id`, the camera is considered global and potentially applies to all users (if its `active_camera` value is high enough)."""
attributes = ["Debuggable", "Networked", "Store"]

[components.aspect_ratio]
type = "F32"
name = "Aspect ratio"
description = """
The aspect ratio of this camera.
If `aspect_ratio_from_window` is set, this will be automatically updated to match the window."""
attributes = ["Debuggable", "Networked", "Store"]

[components.aspect_ratio_from_window]
type = "EntityId"
name = "Aspect ratio from window"
description = "If attached, the `aspect_ratio` component will be automatically updated to match the aspect ratio of the window. Should point to an entity with a `window_physical_size` component."
attributes = ["Debuggable", "Networked", "Store"]
              </code></pre>
            </div>
          </div>
          <aside class="notes">
            Our packages are defined as TOML, including their components, and
            this includes core Ambient definitions, as you can see here.
            However, we need to project these definitions into the Rust code so
            that they can be used. That's where our extreme code generation
            comes in.
          </aside>
        </section>

        <!-- Code generation slide showing semantic analysis -->
        <section>
          <h2>Extreme Code Generation</h2>
          <h3 style="margin-bottom: 0">Semantic analysis</h3>
          <div style="display: flex; align-items: center; height: 80%">
            <div style="flex: 0 0 40%">
              <p>Semantic system as library</p>
              <p>Can be used by both the engine and guest</p>
            </div>
            <div style="flex: 0 0 60%">
              <pre><code style="font-size: 0.45em; white-space: pre-wrap; line-height: 1.2em;" class="language-rust" data-trim data-noescape>
scope:ambient_core::camera (Ambient)
  imports:
  component:ambient_core::camera::active_camera (Ambient)
    type: type:F32 (System)
    name: "Active camera"
    description: "The camera with the highest `active_camera` value will be used for rendering. Cameras are also filtered by the `user_id`.\nIf there's no `user_id`, the camera is considered global and potentially applies to all users (if its `active_camera` value is high enough)."
    default: None
    attributes:
      attribute:Debuggable (System)
      attribute:Networked (System)
      attribute:Store (System)
  component:ambient_core::camera::aspect_ratio (Ambient)
    type: type:F32 (System)
    name: "Aspect ratio"
    description: "The aspect ratio of this camera.\nIf `aspect_ratio_from_window` is set, this will be automatically updated to match the window."
    default: None
    attributes:
      attribute:Debuggable (System)
      attribute:Networked (System)
      attribute:Store (System)
  component:ambient_core::camera::aspect_ratio_from_window (Ambient)
    type: type:EntityId (System)
    name: "Aspect ratio from window"
    description: "If attached, the `aspect_ratio` component will be automatically updated to match the aspect ratio of the window. Should point to an entity with a `window_physical_size` component."
    default: None
    attributes:
      attribute:Debuggable (System)
      attribute:Networked (System)
      attribute:Store (System)
              </code></pre>
            </div>
          </div>
          <aside class="notes">
            The TOML definitions were consumed by our semantic system, which
            then unifies them and determines how all of the packages are linked
            together, much like a compiler. The system is a Rust library, so it
            could be used by the engine at runtime and by guest code at build
            time. You can see some of the system's diagnostic output here.
          </aside>
        </section>

        <!-- Code generation slide showing generated Rust code -->
        <section>
          <h2>Extreme Code Generation</h2>
          <h3 style="margin-bottom: 0">Generation</h3>
          <div style="display: flex; align-items: center; height: 80%">
            <div style="flex: 0 0 40%">
              <div>
                <p>Semantic → Rust code</p>
                <p>Build scripts > Proc macros</p>
                <p><code>src</code>, not <code>OUT_DIR</code></p>
              </div>
            </div>
            <div style="flex: 0 0 60%">
              <pre><code style="font-size: 0.45em; white-space: pre-wrap; line-height: 1em;" class="language-rust" data-trim data-noescape>
                pub mod h3gv2vnpcajq75woh5miemeahfpaku4 {
                  pub fn entity() -&gt; ambient_api::global::EntityId {
                    use ambient_api::once_cell::sync::Lazy;
                    static ENTITY: Lazy&lt;ambient_api::global::EntityId&gt; = Lazy::new(|| {
                        ambient_api::package::get_entity_for_package_id(&quot;h3gv2vnpcajq75woh5miemeahfpaku4&quot;)
                            .expect(&quot;Failed to get package entity - was it despawned?&quot;)
                    });
                    *ENTITY
                  }

                  #[doc = &quot; Auto-generated component definitions.&quot;]
                  pub mod components {
                    use ambient_api::{
                        ecs::{Component, __internal_get_component},
                        once_cell::sync::Lazy,
                        prelude::*,
                    };

                    static PLAYER_MOVEMENT_DIRECTION: Lazy&lt;Component&lt;F32&gt;&gt; = Lazy::new(|| {
                        __internal_get_component(
                            &quot;h3gv2vnpcajq75woh5miemeahfpaku4::player_movement_direction&quot;,
                        )
                    });

                    #[doc = &quot;**Player Movement Direction**: Direction of player movement&quot;]
                    pub fn player_movement_direction() -&gt; Component&lt;F32&gt; {
                        *PLAYER_MOVEMENT_DIRECTION
                    }

                    static TRACK_AUDIO_URL: Lazy&lt;Component&lt;String&gt;&gt; = Lazy::new(|| {
                        __internal_get_component(&quot;h3gv2vnpcajq75woh5miemeahfpaku4::track_audio_url&quot;)
                    });

                    #[doc = &quot;**Track Audio URL**: URL of the track audio\n\n*Attributes*: Networked, Debuggable&quot;]
                    pub fn track_audio_url() -&gt; Component&lt;String&gt; {
                        *TRACK_AUDIO_URL
                    }
                  }
              </code></pre>
            </div>
          </div>
          <aside class="notes">
            Once we have all of the definitions loaded in, Rust code can be
            emitted for them. We initially used procedural macros for this, but
            we switched to build scripts because rust-analyzer struggled and our
            users appreciated being able to see the generated code. These files
            are placed in `src`, not `OUT_DIR`, to make it easier to see. This
            is not the usual practice, but it worked well for us; it improved
            users' understanding of what the system was doing, and made it
            easier for us to develop. Another note worth mentioning here is that
            I would recommend versioning your generated code; it is tremendously
            useful to be able to see exactly what changes between generations.
          </aside>
        </section>

        <!-- Workflow challenges slide with centered list -->
        <section>
          <h2>Workflow</h2>
          <h3>that's a lot of windows</h3>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>Lots of moving parts</li>
              <li>Workspaces aren't perfect</li>
              <li><code>rust-analyzer</code> only uses one workspace</li>
              <li>Five contexts, five windows!</li>
            </ul>
          </div>
          <aside class="notes">
            If you've been keeping count, you'll have noticed that we had a lot
            of moving parts. Rust workspaces do a pretty good job of grouping
            together packages, but they don't support cross-toolchain packages
            (that is, mixing desktop and WASM), and they don't support nesting.
            rust-analyzer works with the workspace you have in the directory
            you've opened in your IDE. As a result, we had up to five VS Code
            windows open: the native client, web client, guest code, cloud
            services, and the website. That was obviously a bit of a struggle.
          </aside>
        </section>

        <!-- Workflow automation slide with code example -->
        <section>
          <h2>Workflow</h2>
          <h3>Automation</h3>
          <div style="display: flex; align-items: center; height: 80%">
            <div style="flex: 0 0 50%">
              <p>cargo-xtask pattern:</p>
              <p>
                <a
                  href="https://github.com/matklad/cargo-xtask"
                  style="font-size: 0.8em"
                  >https://github.com/matklad/cargo-xtask</a
                >
              </p>
              <p>
                Rust tool, <code>campfire</code>, to make common operations easy
                to do
              </p>
              <p>Well worth it</p>
            </div>
            <div style="flex: 0 0 50%">
              <pre><code style="font-size: 0.6em; white-space: pre-wrap; line-height: 1.2em;" class="language-bash" data-trim>
                Ambient # cargo cf --help
                Finished dev [unoptimized + debuginfo] target(s) in 0.66s
                Running `target/debug/campfire --help`

                Usage: campfire &lt;COMMAND&gt;

                Commands:
                  doc            Generate documentation for Ambient
                  package        Package-related functionality
                  golden-images  Running golden image tests
                  release        Release-related functionality
                  install        Helper to install specific versions of Ambient
                  join           Helper to join a server by various means
                  web            Web-related functionality
                  clean          Clean all build artifacts for all packages
                  run            Run a package. Alias for `package run`
                  serve          Serve a package. Alias for `package serve`
                  help           Print this message or the help of the given subcommand(s)

                Options:
                  -h, --help     Print help
                  -V, --version  Print version
              </code></pre>
            </div>
          </div>
          <aside class="notes">
            To help with this, we used the `cargo-xtask` pattern. We built a
            tool in Rust in our root workspace, `campfire`, that could handle
            meta-development tasks like building all of the clients, updating
            package versions, deploying the packages, and more. This was then
            aliased using `cargo/config.toml` to make it easy to access. This
            was an upfront cost, but it paid for itself many times over,
            especially when building for multiple platforms.
          </aside>
        </section>

        <!-- Testing approach slide with image -->
        <!-- Two-column layout with text and image -->
        <section>
          <h2>Workflow</h2>
          <h3>Testing</h3>
          <div
            style="
              display: flex;
              align-items: center;
              justify-content: center;
              height: 80%;
              width: 80%;
              margin: 0 auto;
            "
          >
            <div style="flex: 0 0 55%">
              <p>Golden image tests</p>
              <p>Software rendering for CI</p>
              <p>Still brittle</p>
            </div>
            <div
              style="
                flex: 0 0 45%;
                display: flex;
                align-items: center;
                justify-content: center;
              "
            >
              <img
                src="media/testing.png"
                alt="Golden image test example"
                style="width: 100%"
              />
            </div>
          </div>
          <aside class="notes">
            For testing, we used a combination of unit tests and golden image
            tests: we would run a test case, wait a few seconds, take a
            screenshot, and compare it to a reference image. Using software
            rendering, we were able to run this in our CI. This worked pretty
            well, but it had some drawbacks: Software rendering is very slow and
            unstable and the tests were still brittle due to networking,
            rendering, timing and randomness issues. We considered more complex
            tests and using a GPU-based CI runner, but we didn't have the time
            to implement them.
          </aside>
        </section>

        <!-- Full-width title slide -->
        <section>
          <h1 class="r-fit-text">So what went wrong?</h1>
          <aside class="notes">
            So now it's time to discuss the elephant in the room: what went
            wrong?
          </aside>
        </section>

        <!-- Code example slide -->
        <section>
          <h2>TOML isn't good for everything</h2>
          <pre><code style="font-size: 0.7em; text-wrap: balance; line-height: 1.2em;" class="language-toml" data-trim data-noescape>
[components]
height_offset = { type = "F32", name = "Nameplate Height Offset",
description = "The height offset from the base of this entity at which to render a nameplate. If not specified, it will default to this entity's local bounding AABB Z, and if that's not available, it will default to a constant.", attributes = [
    "Debuggable",
    "Networked",
] }

text_size = { type = "F32", name = "Nameplate Text Size", description = "The text size of the nameplate to render. If not specified, it will default to 2.0.", attributes = [
    "Debuggable",
    "Networked",
] }

hide = { type = "Empty", name = "Nameplate Hide", description = "If attached to a player, hide the nameplate for that player.", attributes = [
    "Networked",
    "Debuggable",
] }
          </code></pre>
          <p>
            Comfy software:
            <a href="https://catgirl.ai/log/comfy-software/"
              >https://catgirl.ai/log/comfy-software/</a
            >
          </p>
          <aside class="notes">
            Let's start with an easy one: our packages were defined with TOML.
            Unfortunately, TOML gets quite ugly for complex structures,
            especially because TOML 1.0 can't do multi-line literals. I wanted
            to do a domain-specific language for defining your schema, but there
            just wasn't enough time. It's ultimately a small thing, but every
            bit of friction is painful. A friend who tried out Ambient
            experienced genuine burnout from this: the experience of defining
            components in TOML and switching to Rust was deeply unpleasant. It
            wasn't "comfy software" - it made you feel worse for using it.
          </aside>
        </section>

        <!-- Centered bullet points slide -->
        <section>
          <h2>Building your own engine is unwise</h2>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>Small team with limited resources</li>
              <li>Untouched parts of the engine</li>
              <li>Building an ecosystem is hard</li>
            </ul>
          </div>
          <aside class="notes">
            If you've talked to any game developer, you'll have heard the
            standard advice: don't build your own engine. Rust solves many
            problems, but it doesn't solve that one. We were a small team of
            less than 10 with limited resources, and building an engine from
            scratch was a huge undertaking. We were able to innovate in ways
            that existing engines couldn't, but everything else suffered. There
            are parts of our engine that saw no love for months, sometimes
            years. On top of that, we were also building an ecosystem, which
            meant we were constantly updating the documentation, examples,
            platform, and more. Was it fun? Yes! Was it sustainable? Absolutely
            not.
          </aside>
        </section>

        <!-- Two-column layout with text and code -->
        <section>
          <h2>Porting the runtime to the web</h2>
          <div style="display: flex; align-items: center; height: 80%">
            <div style="flex: 0 0 60%">
              <p>Just make a new client with the same crates?</p>
              <p>
                WebAssembly / <code>wgpu</code> / <code>winit</code> dream team?
              </p>
              <p>It can't be that simple, right?</p>
            </div>
            <div style="flex: 0 0 40%">
              <pre><code class="language-toml" style="font-size: 0.7em; white-space: pre-wrap; line-height: 1.2em;" data-trim data-noescape>
[package]
name = "ambient_web"
readme = "../README.md"
version.workspace = true
edition = "2021"
description = "Web client for ambient"
license = "MIT OR Apache-2.0"
repository = "https://github.com/AmbientRun/Ambient"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
ambient_app.workspace = true
ambient_audio.workspace = true
ambient_cameras.workspace = true
ambient_client_shared.workspace = true
ambient_core.workspace = true
ambient_debugger.workspace = true
ambient_ecs.workspace = true
              </code></pre>
            </div>
          </div>
          <aside class="notes">
            But the biggest technical challenge we faced was porting the runtime
            to the web. We decided on web support after we'd already built the
            desktop client. Most other engines would struggle to survive this,
            but we had a secret weapon: Rust's native support for WebAssembly.
            As Ambient is modular, we created a new web client targeting
            wasm32-unknown-unknown, and progressively added Ambient's crates to
            it. We created a new client to ensure only the essentials were
            included, and to reduce the scope of any potential discrepancies. We
            believed that this would be straightforward. We had already built on
            top of `wgpu` and `winit`, which would abstract over platform
            specifics. That's all we need to do, right? It can't be that simple,
            right?
          </aside>
        </section>

        <!-- Single line title slide -->
        <section>
          <h1 class="r-fit-text">It was not.</h1>
          <aside class="notes">It was not.</aside>
        </section>

        <!-- Centered bullet points slide -->
        <section>
          <h2>Porting the runtime to the web</h2>
          <h3>Reality</h3>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>Different constraints</li>
              <li>Limited API support</li>
              <li>Performance discrepancies</li>
              <li>Debugging difficulties</li>
            </ul>
          </div>
          <aside class="notes">
            The web is a different beast. It has different constraints,
            different APIs, and different performance characteristics. Many of
            the assumptions we'd made about the desktop didn't hold up on the
            web. Support for the latest APIs was *not* universal; Chrome was the
            only browser that supported everything we used, and it didn't
            support them on Linux. WebAssembly goes a long way towards shrinking
            the discrepancy in performance between web and desktop, but there
            was still a gap. Multithreading on the web was still very much a
            work in progress. Debugging was very difficult, especially with
            async code. The tooling for working with WASM was at least an order
            of magnitude worse than with native.
          </aside>
        </section>

        <!-- Centered bullet points slide -->
        <section>
          <h2>Porting the runtime to the web</h2>
          <h3>System</h3>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li><code>wasm32-unknown-unknown</code> is a lie</li>
              <li>
                <code>wasm-bindgen</code> and <code>web-sys</code> for
                <em>separate</em> system APIs
              </li>
              <li>Tokio doesn't fully work on the web</li>
            </ul>
          </div>
          <aside class="notes">
            Let's be more specific. Let's start with WASM. First, the platform
            itself: wasm32-unknown-unknown, the standard Rust target for WASM on
            the web, is a lie. Much of the standard library will panic at
            runtime, and many APIs are missing. You must use `wasm-bindgen` and
            `web-sys` to interact with the JS APIs and replace that missing
            functionality, but any code relying upon the standard library will
            need to be patched. Our existing code targeted Tokio, which has
            limited support for running on the web. Additionally, you don't
            control task scheduling on the web, unlike on desktop.
          </aside>
        </section>

        <!-- Two-column layout with text and image -->
        <section>
          <h2>Porting the runtime to the web</h2>
          <h3 style="margin-bottom: 0">System</h3>
          <div style="display: flex; align-items: center">
            <div style="flex: 0 0 72%">
              <p>Only solution was our own system abstraction</p>
              <p>Async tasks, timing, file I/O, clipboard, more</p>
              <p>clippy and cargo-deny useful</p>
            </div>
            <div style="flex: 0 0 28%">
              <img
                src="media/ambient_sys.png"
                alt="Ambient system abstraction"
                style="width: 100%"
              />
            </div>
          </div>
          <aside class="notes">
            To fix this, we needed to write our own system abstraction that
            smoothed over the differences between the desktop and the web. This
            abstraction covered: - async tasks - timing - file I/O - the
            clipboard - and more. We had to make sure that any code that could
            potentially run on the web used this abstraction. We used `clippy`
            and `cargo-deny` to help with this, but we still ran into plenty of
            cases where code would panic at runtime.
          </aside>
        </section>

        <!-- Centered comparison with logos -->
        <section>
          <h2>Porting the runtime to the web</h2>
          <h3>WebGPU</h3>
          <div
            style="
              display: flex;
              align-items: center;
              justify-content: center;
              height: 70%;
              gap: 1em;
            "
          >
            <img src="media/wgpu.png" alt="wgpu logo" style="height: 240px" />
            <div style="font-size: 3em">is not</div>
            <img
              src="media/webgpu.png"
              alt="WebGPU logo"
              style="height: 240px"
            />
          </div>
          <aside class="notes">
            Next up, graphics. From the start, we used `wgpu`, which is a
            fantastic abstraction over the various graphics APIs, including
            WebGPU, and meant to serve as the WebGPU implementation for Firefox
            and others. We wanted support for relatively modern graphics, and we
            wanted to be able to use the same code on both the web and desktop.
            We were under the impression that using it would make porting to the
            web using WebGPU straightforward. It *did* make it easier, but,
            well, `wgpu` might be an implementation of WebGPU, but it is *not*
            WebGPU.
          </aside>
        </section>

        <!-- Centered bullet points slide -->
        <section>
          <h2>Porting the runtime to the web</h2>
          <h3>WebGPU problems</h3>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>Bind group count</li>
              <li>Extensions</li>
              <li>Browser compatibility</li>
              <li>Spec interpretation</li>
              <li>Debugging</li>
            </ul>
          </div>
          <aside class="notes">
            I will have to speak in generalities here, as I did not do the bulk
            of the porting work. However, I can say this much. Our renderer was
            designed around having many bind groups, which forced us to redesign
            it when we realised WebGPU only supports a few bind groups. We
            relied on extensions that aren't present on the web, which was
            expected, but still hurt. WebGPU support across browsers was
            basically limited to Windows/Mac Chrome; it is slightly better now,
            but only slightly. WebGPU is still off by default on both Linux and
            Firefox. Each browser has a slightly different interpretation of the
            spec, and their interpretation can differ from wgpu's native
            implementation, including in how they compile shaders. Debugging is
            very difficult - the standard tools don't work, and you're not
            debugging WebGPU, you're debugging your browser's implementation of
            WebGPU. Usual graphics debugging tools, like RenderDoc, work poorly
            with browsers. It's just not a very fun time.
          </aside>
        </section>

        <!-- Centered text conclusion slide -->
        <section>
          <h2>Porting the runtime to the web</h2>
          <h3>WebGPU conclusion</h3>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>We should have used WebGL.</li>
              <li>WebGPU's just not there yet.</li>
            </ul>
          </div>
          <aside class="notes">
            The port we'd budgeted two weeks for ended up being two months long,
            and it didn't work for a sizeable fraction of our audience. In
            hindsight, we should have targeted WebGL at the cost of graphical
            fidelity. We wanted to bring native-like rendering to the web, but
            it just wasn't there yet.
          </aside>
        </section>

        <!-- Centered text with networking info -->
        <section>
          <h2>Porting the runtime to the web</h2>
          <h3>WebTransport</h3>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>Networking with quinn, which implements QUIC</li>
              <li>QUIC ≈ WebTransport?</li>
            </ul>
          </div>
          <aside class="notes">
            For networking, we used the `quinn` library, which implements the
            QUIC protocol. QUIC is a fantastic protocol that provides secure
            reliable and unreliable data streams, which gave us a strong
            transport layer for our networking. WebTransport is a sibling
            protocol of QUIC that shares a great deal with it, and the majority
            of browsers have native client support for it. We assumed that
            having the web client use WebTransport to connect to the server
            would be straightforward. Unfortunately, just like with WebGPU, it's
            not quite the same thing.
          </aside>
        </section>

        <!-- Two-column layout with text and image -->
        <section>
          <h2>Porting the runtime to the web</h2>
          <h3>WebTransport</h3>
          <div style="display: flex; align-items: center">
            <div style="flex: 0 0 60%">
              <p>QUIC ≈ WebTransport</p>
              <p>⇏</p>
              <p>QUIC = WebTransport</p>
            </div>
            <div style="flex: 0 0 40%">
              <img
                src="media/h3-issue.png"
                alt="h3 issue"
                style="width: 100%"
              />
            </div>
          </div>
          <aside class="notes">
            Despite being strongly related, WebTransport is a separate protocol
            from QUIC, which required parallel implementation on both the client
            and server. There was no existing support for WebTransport on the
            server in Rust, so we worked with the open-source community to add
            WebTransport support to `h3`. This took a while. We also had to add
            support for the WebTransport API to our web client, but we were able
            to abstract over the differences between WebTransport and QUIC
            thanks to their shared ancestry.
          </aside>
        </section>

        <!-- Centered bullet points slide -->
        <section>
          <h2>Porting the runtime to the web</h2>
          <h3>Performance</h3>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>
                Networking, rendering and logic all ran on the same thread!
              </li>
              <li>Messages dropped</li>
              <li>Scripting overhead</li>
            </ul>
          </div>
          <aside class="notes">
            After all this, though, we discovered that networking, rendering and
            logic ran on the same thread on the web - remember, no
            multithreading - which meant that messages would be dropped if the
            client was too busy. Our WASM scripting had severe overhead in the
            web environment. This was catastrophic, and we added a few
            workarounds - including dropping frames to allow networking to catch
            up and experimenting with Web Workers - but we did not come up with
            a general solution, and the web client's experience very quickly
            degraded under load.
          </aside>
        </section>

        <!-- Centered bullet points slide -->
        <section>
          <h2>Using WebAssembly for Scripting</h2>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
              gap: 1em;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: right;
              "
            >
              <li>Game engines usually use Lua or such</li>
              <li>But how do you support many languages?</li>
              <li>Let’s try</li>
            </ul>

            <img
              src="media/wasm.png"
              alt="WebAssembly logo"
              style="height: 240px"
            />
          </div>
          <aside class="notes">
            I've built my fair share of scriptable applications, and I've
            typically done this with Lua or other languages amenable to
            embedding. A problem that I've always encountered while doing so,
            however, is that you're locked into whatever language you've
            embedded. The only way to add more languages was to add more
            interpreters. This time around, we decided to use WebAssembly for
            scripting, which is a language-independent bytecode format. Despite
            what the name suggests, it can be used outside of the web! In
            theory, we could use any language that compiles to WebAssembly, and
            we could have Rust as a first-class guest language. In practice, the
            story is not so simple.
          </aside>
        </section>

        <!-- Centered bullet points slide -->
        <section>
          <h2>Using WebAssembly for Scripting</h2>
          <h3>How?</h3>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
              gap: 1em;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>On the web, "just" use the browser</li>
              <li>On native, you need a runtime: <code>wasmtime</code>.</li>
              <li>How do you bind host code?</li>
            </ul>
          </div>
          <aside class="notes">
            First problem, how do you actually run WebAssembly? On the web, you
            can just use the browser's WebAssembly runtime - at least in theory
            - but we needed a way to run it natively. There are a couple of
            interpreters, but we chose the Bytecode Alliance’s Wasmtime for this
            as it had a JIT compiler, natively supported Rust as a host, and was
            at the forefront of WASM development. In doing so, however, we
            discovered our second problem: how do you bind Rust types to
            WebAssembly, which only has a C-like ABI?
          </aside>
        </section>

        <!-- Two-column layout with text and code -->
        <section>
          <h2>Using WebAssembly for Scripting</h2>
          <h3>wit-bindgen</h3>
          <div style="display: flex; align-items: center; height: 80%">
            <div style="flex: 0 0 60%">
              <p>
                <code>wit-bindgen</code> to the rescue! well, <em>sort of</em>
              </p>
              <p>WIT only supported so much</p>
            </div>
            <div style="flex: 0 0 40%">
              <pre><code class="language-wit" style="font-size: 0.6em; white-space: pre-wrap; line-height: 1.2em;" data-trim data-noescape>
interface entity {
  use types.{entity-id, vec3, quat, mat4}
  use component.{entity as entity-data}

  get-transforms-relative-to: func(
    entities: list&lt;entity-id&gt;, origin: entity-id
  ) -&gt; list&lt;mat4&gt;

  spawn: func(data: entity-data) -&gt; entity-id
  despawn: func(entity: entity-id) -&gt; option&lt;entity-data&gt;
  in-area: func(position: vec3, radius: float32) -&gt; list&lt;entity-id&gt;

  exists: func(entity: entity-id) -&gt; bool
  get-all: func(index: u32) -&gt; list&lt;entity-id&gt;
  resources: func() -&gt; entity-id
  synchronized-resources: func() -&gt; entity-id
  persisted-resources: func() -&gt; entity-id
}
              </code></pre>
            </div>
          </div>
          <aside class="notes">
            Luckily, the Bytecode Alliance had a solution for this: wit-bindgen.
            Unluckily, it was still in development when we picked it up, and we
            discovered that it was part of the greater Component Model proposal,
            which was still being designed. This meant that we were following a
            changing implementation and spec, which led to churn on our part.
            The interface is specified in WIT, which is an interface definition
            language for the Component Model, which you can see an example of
            here. It supports a subset of what Rust supports, which meant we had
            to be careful in how we designed our API.
          </aside>
        </section>

        <!-- Two-column layout with text and code -->
        <section>
          <h2>Using WebAssembly for Scripting</h2>
          <h3>wit-bindgen</h3>
          <div style="display: flex; align-items: center; height: 80%">
            <div style="flex: 0 0 45%">
              <p>Still needed glue code</p>
              <p>Data model didn't quite align</p>
              <p>Only a few languages supported</p>
            </div>
            <div style="flex: 0 0 55%">
              <pre><code class="language-rust" style="font-size: 0.7em; white-space: pre-wrap; line-height: 1.2em;" data-trim data-noescape>
// Rust implementation of the WIT interface
pub fn exists(entity: EntityId) -&gt; bool {
    wit::entity::exists(entity.into_bindgen())
}

/// Gets all of the entities that have the given &grave;component&grave;.
pub fn get_all&lt;T&gt;(component: Component&lt;T&gt;) -&gt; Vec&lt;EntityId&gt; {
    wit::entity::get_all(component.index()).from_bindgen()
}

/// Gets all of the entities within &grave;radius&grave; of &grave;position&grave;.
pub fn in_area(position: Vec3, radius: f32) -&gt; Vec&lt;EntityId&gt; {
    wit::entity::in_area(position.into_bindgen(), radius).from_bindgen()
}
              </code></pre>
            </div>
          </div>
          <aside class="notes">
            Unfortunately, the generated WIT code wasn't ergonomic, so we still
            had to write our own glue code for the guest API. Because of this,
            we were effectively stuck with a Rust guest, despite ostensibly
            being able to use any language with WASM. In hindsight, we should
            have considered writing our own binding layer - WIT is great, and I
            wish the best for it, but it wasn't the right fit for our
            constraints. Also, wit-bindgen's language support was limited; even
            if we did support other guests, the choices would have been very
            limited, and would not have included scripting languages.
          </aside>
        </section>

        <!-- Centered bullet points slide -->
        <section>
          <h2>Using WebAssembly for Scripting</h2>
          <h3>WebAssembly System Interface</h3>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: right;
              "
            >
              <li>
                <code>wasm32-wasi</code> (now <code>wasm32-wasip1</code>) is
                less of a lie!
              </li>
              <li>We can use it for guest code 😀</li>
              <li>but it still needs implementation… 😭</li>
              <li><code>preview1</code> ≠ <code>preview2</code></li>
            </ul>
          </div>
          <aside class="notes">
            Earlier, I mentioned that wasm32-unknown-unknown doesn't implement
            any system interfaces. Luckily, that’s less of a problem for our
            guest code; we could use wasm32-wasi, powered by the WebAssembly
            System Interface. Our engine - the host - can then implement the
            host side of the interface, so that the guest can use these APIs
            without a care in the world. Rust supports the first preview of
            preview of WASI, but our use of the Component Model forced us onto
            the second preview, which was still in development. This meant we
            had to use an adapter, and have our own custom implementation of the
            WASI APIs. The APIs were frequently changing, leading to more churn
            for us.
          </aside>
        </section>

        <!-- Single line slide with headers -->
        <section>
          <h2>Using WebAssembly for Scripting</h2>
          <h3>On the web</h3>
          <p>We could just use the browser's runtime, right?</p>
          <aside class="notes">
            After a lot of work, we did eventually get desktop scripting working
            reasonably well. The next challenge was to get it working on the
            web. We could just use the browser's runtime, right?
          </aside>
        </section>

        <!-- Centered image slide -->
        <section>
          <h2>Using WebAssembly for Scripting</h2>
          <h3>On the web</h3>
          <img
            src="media/well-yes-but-actually-no.png"
            alt="Well yes, but actually no"
            style="width: 50%; height: auto"
          />
          <aside class="notes">Well yes, but actually no.</aside>
        </section>

        <!-- Two-column layout with text and image -->
        <section>
          <h2>Using WebAssembly for Scripting</h2>
          <h3>On the web</h3>
          <div
            style="
              display: flex;
              align-items: center;
              justify-content: center;
              height: 80%;
              width: 80%;
              margin: 0 auto;
            "
          >
            <div style="flex: 0 0 50%">
              <p>
                <code>wasm32-wasi</code> and Component Model didn't exist on the
                web
              </p>
              <p>
                Luckily, we were not alone: thanks, <code>wasm-bridge</code>!
              </p>
            </div>
            <div
              style="
                flex: 0 0 50%;
                display: flex;
                align-items: center;
                justify-content: center;
              "
            >
              <img
                src="media/wasm-bridge.png"
                alt="wasm-bridge repository"
                style="width: 100%"
              />
            </div>
          </div>
          <aside class="notes">
            Our guest code uses wasm32-wasi and the Component Model, neither of
            which were supported on the web. This meant we had to write a web
            backend for our scripting, and then wire that backend up to the
            Component Model. Web support for the Component Model is coming, but
            wasn't ready when we needed it. Luckily, we were not alone; another
            developer, Karel, had already encountered this problem, and built
            wasm-bridge, which wraps WebAssembly components in a JS object,
            allowing for their use in a web environment. We adapted it to run
            our guest code on the web.
          </aside>
        </section>

        <!-- Two-column layout with text and image -->
        <section>
          <h2>Using WebAssembly for Scripting</h2>
          <h3>On the web</h3>
          <div
            style="
              display: flex;
              align-items: center;
              justify-content: center;
              height: 80%;
              width: 80%;
              margin: 0 auto;
              gap: 32px;
            "
          >
            <div style="flex: 0 0 50%">
              <p><code>wasm-bridge</code> used <code>jco</code></p>
              <p>
                <code>jco</code> wrapped WebAssembly components in JavaScript
              </p>
              <p>JavaScript FFI has overhead</p>

              <img src="media/oh-no.png" alt="oh no" style="width: 50%" />
            </div>
            <div
              style="
                flex: 0 0 50%;
                display: flex;
                align-items: center;
                justify-content: center;
              "
            >
              <img
                src="media/jco.png"
                alt="jco repository"
                style="width: 100%"
              />
            </div>
          </div>
          <aside class="notes">
            However... wasm-bridge is based upon the Bytecode Alliance's JCO
            project, which wrapped WebAssembly components in a JS object.
            wasm-bridge wrapped the resulting JavaScript code with a Rust
            interface. This resulted in double-FFI with JavaScript, which was
            *very* slow. We optimised this as much as we could, but we came to
            the conclusion that we needed to remove the JS from the equation.
            This was the main cause of our performance issues on the web.
          </aside>
        </section>

        <!-- Two-column layout with text and image -->
        <section>
          <h2>Using WebAssembly for Scripting</h2>
          <h3>On the web</h3>
          <div style="margin: 0 auto">
            <p><code>wasm_component_layer</code> maybe could have saved us?</p>
            <img
              src="media/wasm-component-layer.png"
              alt="wasm_component_layer"
              style="width: 50%; display: block; margin: 0 auto"
            />
          </div>
          <aside class="notes">
            We found Douglas Dwyer's wasm_component_layer, which provides a
            runtime-agnostic implementation of the Component Model. We started
            integrating it, but were unable to complete the integration before
            moving on, which meant the web client was never fixed. Given that
            the scripting was still likely to run on the same thread, this would
            have only partially addressed the problem.
          </aside>
        </section>

        <!-- Centered bullet points slide -->
        <section>
          <h2>Using WebAssembly for Scripting</h2>
          <h3>Other issues</h3>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>Debugging sucks</li>
              <li>Module compile time is slow</li>
              <li>No ability to interpret</li>
              <li>Other languages never happened</li>
            </ul>
          </div>
          <aside class="notes">
            There were other issues we encountered with WebAssembly. Debugging
            is difficult. It's theoretically possible - we had it working
            outside of Ambient - but we couldn't get it working inside, forcing
            you to use print debugging. Wasmtime compiles modules as it loads
            them, which takes time. With many modules, it can stall startup for
            many seconds, as you saw in the demo. There was no way to quickly
            interpret code, which meant modules *had* to be compiled. Finally,
            we never got around to trying out other languages, which meant there
            was ultimately no point in using WebAssembly.
          </aside>
        </section>

        <!-- Centered bullet points slide -->
        <section>
          <h2>Using WebAssembly for Scripting</h2>
          <h3>Conclusion</h3>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>
                There’s certainly promise, but... there are also major problems.
              </li>
              <li>Just use a conventional scripting language.</li>
            </ul>
          </div>
          <aside class="notes">
            In conclusion: WebAssembly showed promise for this use case, but
            like WebGPU, the pieces still need to come together. You can’t run
            many scripting-relevant languages on it, binding is difficult, and
            supporting both desktop and web is very challenging. I’d recommend a
            conventional scripting language like Lua, Ruby or Python -
            especially as all of those now have Rust implementations!
          </aside>
        </section>

        <!-- Single line title slide -->
        <section>
          <h1 class="r-fit-text">Our biggest issue</h1>
          <aside class="notes">
            Finally, our biggest issue… was that people just weren’t interested.
            We built a lot of cool tech, but we couldn’t get people to care. I
            believe that with enough time, we could have made this work, but
            that time wasn't at hand. After this, we experimented with
            AI-enhanced gamedev under the Braindump banner, but that's a story
            for another talk.
          </aside>
        </section>

        <!-- Centered bullet points slide -->
        <section>
          <h2>What did we learn?</h2>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>
                Rust was the right language for this, but “this” was wrong
              </li>
              <li>Check in regularly with other projects</li>
              <li>Implement web support from day one</li>
              <li>Use conventional scripting</li>
              <li>Use WebGL over WebGPU</li>
              <li>Build things people want</li>
            </ul>
          </div>
          <aside class="notes">
            So, what did we learn from all of this? We were confident that Rust
            was the right choice for the engine. We just didn’t know what we
            wanted to build, and we were subject to the limitations of
            technologies out of our control. By the time Ambient was born, Bevy
            and other engines were actively developed and were closer to what we
            needed. We should have investigated how much work it would have been
            to switch to them. We tried to retroactively add web support, but
            this should have been a core part of the engine from the beginning.
            At a minimum, we should have gone with a more conventional scripting
            language and WebGL over WebAssembly and WebGPU. These are fantastic
            technologies, but they're just not ready yet: WebAssembly's
            ecosystem is still maturing, and WebGPU has growing pains. Finally,
            we needed to meet people where they were. We built all of this cool
            technology, but we couldn’t convince people to use it. We needed to
            talk to users first and solve the problems they had, not the
            problems we thought they had.
          </aside>
        </section>

        <!-- Conclusion slide -->
        <section>
          <h2>Conclusion and Q&A</h2>
          <p>
            <a href="https://github.com/AmbientRun/Ambient"
              >https://github.com/AmbientRun/Ambient</a
            >
          </p>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              width: 100%;
              gap: 32px;
            "
          >
            <div
              style="
                display: flex;
                align-items: center;
                flex: 1;
                justify-content: flex-end;
              "
            >
              <img
                src="media/philpax.png"
                alt="Philpax avatar"
                style="max-width: 240px"
              />
            </div>
            <div style="flex: 1; text-align: left">
              <p>Mithun Hunsur</p>
              <p><em>@</em><a href="https://philpax.me">philpax.me</a></p>
            </div>
          </div>
          <aside class="notes">
            Thanks for listening! You can find the Ambient repo at the link
            above, but it hasn't been updated since 2023, and many of the
            associated services are now down. You can find me on Bluesky at
            @philpax.me (also my website!) I'll take questions now, but I'll be
            around if you'd like to talk more.
          </aside>
        </section>
      </div>
    </div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
