<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
      A Post-Mortem On Ambient: A Rust/WebAssembly Runtime for Cross-Platform
      Multiplayer Games
    </title>
    <link rel="stylesheet" href="/node_modules/reveal.js/dist/reveal.css" />
    <link
      rel="stylesheet"
      href="/node_modules/reveal.js/dist/theme/serif.css"
    />
    <link
      rel="stylesheet"
      href="/node_modules/reveal.js/plugin/highlight/zenburn.css"
    />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!-- Title slide with main heading and subtitle -->
        <section>
          <h2>A Post-Mortem On Ambient</h2>
          <h4>
            What <em>Was</em> A Rust/WebAssembly Runtime for Cross-Platform
            Multiplayer Games
          </h4>
          <p>Mithun Hunsur (<a href="https://philpax.me">philpax.me</a>)</p>
          <aside class="notes">
            <p>
              G'day everyone! I'm here today to talk to you about Ambient, the
              open-source cross-platform multiplayer game runtime that I worked
              on from early 2023 to late 2023.
            </p>
            <p>
              I'll tell you about the project, what we did well, and what went
              wrong. This is an adapted version of my talk at Rust Nation UK
              2024; Ambient is dead and won't be coming back, so I can speak
              with more finality. There are also things I'm leaving out for
              time, but I'd be happy to discuss them with you after the talk.
            </p>
          </aside>
        </section>

        <!-- Speaker introduction slide with contact info and projects -->
        <section>
          <h2>Who am I?</h2>
          <h3>Mithun Hunsur</h3>
          <div style="text-align: left">
            <p><em>currently</em> not doing Rust professionally 😭</p>
            <p><em>formerly</em> <strong>Senior Engineer</strong> @ Ambient</p>
            <p>
              <em>formerly</em> <strong>Multiplayer Programmer</strong> @
              Avalanche Studios
            </p>
            <p>
              <em>formerly</em> <strong>Co-Lead Developer</strong> @ Just Cause
              2 Multiplayer
            </p>
            <p><small>and a lot of other things</small></p>
          </div>
          <aside class="notes">
            <p>
              First off, let me introduce myself. My name's Mithun, but I go by
              Philpax online. I'm all over the shop, but my home base is in
              games, where I've been working on multiplayer projects for over a
              decade.
            </p>
            <p>
              During 2022 to late 2024, I worked at Ambient, also known as Dims
              and Braindump, to explore new ways of creating multiplayer games
              to enable both local and global collaboration.
            </p>
            <p>
              Before that, I worked at Avalanche Studios as a triple-A gamedev,
              and well before that, I worked on a volunteer project to make Just
              Cause 2 a massively multiplayer game with scripting.
            </p>
            <p>
              Nowadays, I work on productionising AI as a machine learning
              engineer at my current workplace.
            </p>
            <p>
              In my free time, I work on all kinds of things, including
              open-source AI, projects this close *pinching* to release, and
              more.
            </p>
          </aside>
        </section>

        <!-- Introduction to Ambient slide -->
        <section>
          <h1>What was Ambient?</h1>
          <aside class="notes">
            <p>So, what was the Ambient runtime?</p>
            <p>
              Multiplayer game development is challenging. Most of the existing
              solutions were lacking in some way: they didn't support
              multiplayer, they weren't cross-platform, or they limited the
              developer's creativity.
            </p>
            <p>
              We were a VC-backed startup that wanted to solve this problem and
              make it easy for people to build multiplayer games. We took on a
              large burden, and I'm proud of how far we got, but you'll see why
              it didn't work out.
            </p>
          </aside>
        </section>

        <!-- Video background slide showing Dims project -->
        <section
          data-background-video="media/dims.mp4"
          data-background-video-loop
          data-background-video-muted
        >
          <aside class="notes">
            <p>
              Getting to Ambient took a few tries. What you're seeing here was
              our first attempt to solve multiplayer game development. This was
              Dims, a collaborative low-code game development platform, also
              built in Rust, almost entirely created by our CPTO, Fredrik Norén.
            </p>
            <p>
              You can build worlds, hang out together, and share them with
              others. This was made possible by a multiplayer, concurrent
              editor. I joined around the time of this video to help scale up
              Dims.
            </p>
            <p>
              However, worlds aren't games; to bring your project to life, we
              decided to let you script your games with WebAssembly. And then we
              realised it was becoming something else entirely.
            </p>
          </aside>
        </section>

        <!-- Ambient logo and feature list slide with two columns -->
        <section>
          <div style="text-align: center">
            <img
              src="media/logo.svg"
              alt="Ambient"
              style="height: 140px; margin: 0 auto; margin-top: 60px"
            />
          </div>
          <div style="display: flex; align-items: top">
            <div
              style="flex: 0 0 50%; display: flex; justify-content: flex-end"
            >
              <ul
                style="
                  list-style: none;
                  text-align: right;
                  font-size: 1.2em;
                  margin: 0;
                  margin-right: 20px;
                  padding: 0;
                "
              >
                <li>Batteries-included</li>
                <li>Open-source</li>
                <li>Multiplayer-first</li>
                <li>Cross-platform</li>
                <li>WebAssembly</li>
                <li>Web support</li>
                <li>Package-centric workflow</li>
              </ul>
            </div>
            <div style="flex: 0 0 50%">
              <img
                src="media/screenshot.png"
                style="width: 100%; height: auto; margin: 0"
              />
            </div>
          </div>
          <aside class="notes">
            <p>
              We took the core engine of Dims, cleaned it up, removed the
              existing editor and "game logic", and open-sourced it to create
              Ambient. Once that was done, we scaled up the scripting, built a
              package ecosystem, ported it to the web, and wrapped a cloud
              platform around it.
            </p>
            <p>
              That is to say: Ambient was a modern open-source multiplayer-first
              cross-platform game runtime with WebAssembly-based scripting, web
              support, and a package-centric workflow.
            </p>
            <p>
              All of this was backed by the "Ambient Platform", that allowed
              users to build, play, and publish packages and games.
            </p>
          </aside>
        </section>

        <!-- Slide showing all components built in Rust with Rustacean overlay -->
        <section>
          <div
            style="
              position: relative;
              display: flex;
              flex-direction: column;
              justify-content: center;
              align-items: center;
              height: 100%;
            "
          >
            <ul
              style="
                list-style: none;
                text-align: center;
                padding: 0;
                margin: 0;
                font-size: 1.5em;
                line-height: 1.5;
              "
            >
              <li>Game server</li>
              <li>Desktop client</li>
              <li>Web client</li>
              <li>Scripting</li>
              <li>Build automation</li>
              <li>Cloud services</li>
              <li>Website</li>
            </ul>
            <div
              class="fragment"
              style="
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10;
              "
            >
              <img
                src="media/rustacean.png"
                style="width: 60%; opacity: 0.6"
                alt="Rustacean"
              />
            </div>
          </div>
          <aside class="notes">
            <p>
              And of course, all of this was written in Rust. And I mean *all*
              of it. The game server? The desktop client? The web client? The
              scripting? The build automation? The cloud services? The website?
            </p>
            <p>*click* The crab comes for us all.</p>
            <p>
              The primary focus today will be on the game engine, but I'll
              briefly touch upon the website as well.
            </p>
          </aside>
        </section>
        <!-- Slide explaining why Rust was chosen -->
        <section>
          <h2>Why Rust?</h2>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>Performance</li>
              <li>Modern features</li>
              <li>Cross-platform code</li>
              <li>General-purpose use</li>
              <li>Code sharing</li>
            </ul>
          </div>
          <aside class="notes">
            <p>
              A game engine requires performance, which typically means C++. But
              we chose Rust. We wanted a safe and performant language with
              modern conveniences.
            </p>
            <p>
              We wanted the tooling: cargo, clippy, rustfmt. We wanted native
              support for concurrency and parallelism. We wanted a rich,
              reliable package ecosystem. We wanted to confidently refactor code
              with ease. We wanted easy cross-platform support. And we wanted a
              strong type system, including enums, traits, and more, all backed
              by the borrow checker.
            </p>
            <p>
              Rust is also a fantastic general-purpose language, which is why we
              decided to use it for everything. In theory, this allowed us to
              easily share code and do more with less.
            </p>
          </aside>
        </section>

        <!-- Two-column slide listing engine features -->
        <section>
          <div
            style="
              display: flex;
              justify-content: space-between;
              height: 100%;
              align-items: center;
            "
          >
            <div style="flex: 1">
              <div
                style="
                  display: flex;
                  flex-direction: column;
                  gap: 0.6em;
                  padding: 0;
                  margin: 0;
                  font-size: 1.4em;
                  text-align: center;
                  line-height: 1.2;
                "
              >
                <div>ECS</div>
                <div>Physically-based rendering</div>
                <div>Asset pipeline</div>
                <div>WASM scripting</div>
                <div>Dynamically-loaded packages</div>
              </div>
            </div>
            <div style="flex: 1">
              <div
                style="
                  display: flex;
                  flex-direction: column;
                  gap: 0.6em;
                  padding: 0;
                  margin: 0;
                  font-size: 1.4em;
                  text-align: center;
                  line-height: 1.2;
                "
              >
                <div>Spatial audio</div>
                <div>Character animation</div>
                <div>PhysX</div>
                <div>React-like UI</div>
                <div>Web support</div>
              </div>
            </div>
          </div>
          <aside class="notes">
            <p>
              Now, let's talk features. We were a batteries-included runtime, so
              we made sure our engine had everything you might need to build a
              game, as you can see here.
            </p>
            <p>
              At the time, we believed we offered more of a batteries-included
              experience than Bevy, especially for multiplayer games. However,
              Bevy has come a long way since, including the surrounding
              ecosystem.
            </p>
            <p>
              That being said, the most innovative items on this list are the
              packages, WASM scripting, and web support. Let's start with the
              packages.
            </p>
          </aside>
        </section>

        <!-- Slide about packages with TOML example -->
        <section>
          <h2 style="font-size: 1.8em">
            Packages: Rust crates, but for gamedev?
          </h2>
          <div style="display: flex; align-items: center; height: 80%">
            <div style="flex: 0 0 45%">
              <p>What can you do when you make your ECS dynamic?</p>
              <p>What does the ultimate moddable game platform look like?</p>
            </div>
            <div style="flex: 0 0 55%">
              <pre><code style="font-size: 0.7em; white-space: pre-wrap; line-height: 1.2em;" class="language-toml" data-trim data-noescape>
[package]
id = "jkr622pbesmaco76bjc6116v4t41ajh"
name = "Screen Ray"

[messages.Input.fields]
ray_origin = "Vec3"
ray_dir = "Vec3"
spawn = "Bool"

[components.player_cube_ref]
name = "Player Cube Ref"
description = "Attached to the player; references the preview cube the player is controlling."
type = "EntityId"
attributes = ["Networked", "Debuggable"]

[dependencies]
orbit_camera = {id = "tijz7x6fimbgu24sbbtp4n1lhfxbgb1p", version = "0.3.2"}
              </code></pre>
            </div>
          </div>
          <aside class="notes">
            <p>
              Like many modern game engines, we used an entity component system
              - an ECS - in which entities have components, which are pieces of
              data, and these entities and their components are acted upon by
              systems. However, we wanted to go a step further.
            </p>
            <p>
              I grew up with Garry's Mod, where you could load code and assets
              at runtime to extend the game experience, and I evolved that in
              Just Cause 2: Multiplayer. We wanted to build a modern take, which
              led us to our runtime-loadable packages, inspired heavily by Rust
              crates.
            </p>
            <p>
              These can add new components, bring in new assets, load new WASM
              modules, and even message each other. And of course, they can
              depend on other packages.
            </p>
            <p>
              This was an evolution of ideas that I'd been working on since
              JC2:MP. The core engine is designed to be microkernel-like,
              providing core functionality, but all game logic lives in the
              scripting layer, so that it can be endlessly modified and composed
              at runtime.
            </p>
          </aside>
        </section>

        <!-- Demo announcement slide -->
        <section>
          <h1 class="r-fit-text">Demo time!</h1>
          <h2>Tangent</h2>
          <h3>a simple 3D multiplayer game</h3>
          <aside class="notes">
            <p>
              Unfortunately, as our web services have gone down, I can't show
              you the full Ambient experience; this means no web client, no
              cloud packages, and no modding. However, I can at least show you
              what the multiplayer experience is like with Tangent, a simple 3D
              multiplayer game where you control a protagonist that can run
              around, get into a hovercraft, and shoot at each other. I can also
              briefly take you through how packages are structured, and how
              scripting works.
            </p>
            <p>
              Tangent consists of many packages that interact with each other
              through a shared protocol. In theory, anyone could target this
              protocol to write mods for Tangent.
            </p>
            <p>
              As you can see, this doesn't look as pretty as the Dims demo. The
              engine is still as technically capable as before, but getting art
              style right is hard without an editor. The explosions aren't
              particularly fancy, either: we had no particle system.
            </p>
          </aside>
        </section>

        <!-- Slide about using Rust as scripting language with code example -->
        <section>
          <h2>Using Rust for Scripting</h2>
          <div style="display: flex; align-items: center; height: 80%">
            <div style="flex: 0 0 50%; font-size: 0.8em; text-align: right">
              <p>Easy to share code with the host</p>
              <p>Still complex, even with API hiding complexity</p>
              <p>Slow WASM compile times hinder rapid iteration</p>
              <p>Rust is a bit scary to new users</p>
              <p>A higher-level language would be better. Grain?</p>
            </div>
            <div style="flex: 0 0 50%">
              <pre><code style="font-size: 0.55em; white-space: pre-wrap; line-height: 1.2em;" class="language-rust" data-trim data-noescape>
#[main]
pub fn main() {
    Entity::new()
        .with(quad(), ())
        .with(scale(), Vec3::ONE * 10.)
        .with(color(), vec4(1., 0., 0., 1.))
        .with(plane_collider(), ())
        .spawn();

    Entity::new()
        .with_merge(Sphere::suggested())
        .with(sphere_collider(), 0.5)
        .with(translation(), vec3(5., 5., 1.))
        .spawn();

    spawn_query(is_player()).bind(move |players| {
        for (id, _) in players {
            entity::add_components(
                id,
                Entity::new()
                    .with_merge(ThirdPersonController::suggested())
                    .with(camera_distance(), 0.0),
            );
        }
    });
}
              </code></pre>
            </div>
          </div>
          <aside class="notes">
            <p>
              As you might have noticed in the demo, we used Rust as our
              scripting language. This is made possible through WebAssembly -
              more on that later. We liked using Rust for scripting, and it let
              us share a lot of code, which was fantastic for letting us change
              things on the host and the guest at the same time.
            </p>
            <p>
              However, the language is still somewhat complex, despite our
              attempts to hide it under the API. The compile times were OK, but
              not fantastic: game developers appreciate fast iteration times of
              a few seconds at most, but it could be 15-30 seconds with Ambient.
            </p>
            <p>
              We also had a concern that the use of Rust might scare off
              potential users; we found that users were fine with it once they
              got used to it, but it was definitely a barrier to entry. I
              believe a slightly higher-level language would be better for this
              use case, but I'm not sure what that would look like. Perhaps
              Grain, which is a ML-like language targeting WebAssembly, would be
              a good fit.
            </p>
          </aside>
        </section>

        <!-- Data model slide showing data model in TOML -->
        <section>
          <h2 style="margin-bottom: 0">Data model and code generation</h2>
          <div style="display: flex; align-items: center; height: 80%">
            <div style="flex: 0 0 40%">
              <p>Package definitions in TOML, but projected into Rust</p>
              <p>Build scripts > proc macros</p>
              <p><code>src</code>, not <code>OUT_DIR</code></p>
              <p>Version your generated code!</p>
            </div>
            <div style="flex: 0 0 60%">
              <pre><code style="font-size: 0.45em; white-space: pre-wrap; line-height: 1.2em;" class="language-toml" data-trim data-noescape>
[package]
name = "Camera"
description = "Camera matrices, types, parameters, and more."
content = { type = "Asset", schema = true }
version = "0.3.2-dev"
ambient_version = "0.3.2-nightly-2023-12-21"

[components.active_camera]
type = "F32"
name = "Active camera"
description = """
The camera with the highest `active_camera` value will be used for rendering. Cameras are also filtered by the `user_id`.
If there's no `user_id`, the camera is considered global and potentially applies to all users (if its `active_camera` value is high enough)."""
attributes = ["Debuggable", "Networked", "Store"]

[components.aspect_ratio]
type = "F32"
name = "Aspect ratio"
description = """
The aspect ratio of this camera.
If `aspect_ratio_from_window` is set, this will be automatically updated to match the window."""
attributes = ["Debuggable", "Networked", "Store"]

[components.aspect_ratio_from_window]
type = "EntityId"
name = "Aspect ratio from window"
description = "If attached, the `aspect_ratio` component will be automatically updated to match the aspect ratio of the window. Should point to an entity with a `window_physical_size` component."
attributes = ["Debuggable", "Networked", "Store"]
              </code></pre>
            </div>
          </div>
          <aside class="notes">
            <p>
              Our packages are defined as TOML, including their components, and
              this includes core Ambient definitions, as you can see here.
              However, we need to project these definitions into the Rust code
              so that they can be used.
            </p>
            <p>
              We initially used procedural macros for this, but we switched to
              build scripts because rust-analyzer struggled and our users
              appreciated being able to see the generated code.
            </p>
            <p>
              These files are placed in `src`, not `OUT_DIR`, to make it easier
              to see. This is not the usual practice, but it worked well for us;
              it improved users' understanding of what the system was doing, and
              made it easier for us to develop.
            </p>
            <p>
              Another note worth mentioning here is that I would recommend
              versioning your generated code; it is tremendously useful to be
              able to see exactly what changes between generations.
            </p>
          </aside>
        </section>

        <!-- Workflow automation slide with code example -->
        <section>
          <h2>Workflow automation</h2>
          <div style="display: flex; align-items: center; height: 80%">
            <div style="flex: 0 0 50%">
              <p>Workspaces aren't perfect</p>
              <p>Five contexts, five windows!</p>
              <p>cargo-xtask pattern:</p>
              <p>
                <a
                  href="https://github.com/matklad/cargo-xtask"
                  style="font-size: 0.8em"
                  >https://github.com/matklad/cargo-xtask</a
                >
              </p>
              <p>
                Rust tool, <code>campfire</code>, to make common operations easy
                to do
              </p>
              <p>Well worth it</p>
            </div>
            <div style="flex: 0 0 50%">
              <pre><code style="font-size: 0.6em; white-space: pre-wrap; line-height: 1.2em;" class="language-bash" data-trim>
                Ambient # cargo cf --help
                Finished dev [unoptimized + debuginfo] target(s) in 0.66s
                Running `target/debug/campfire --help`

                Usage: campfire &lt;COMMAND&gt;

                Commands:
                  doc            Generate documentation for Ambient
                  package        Package-related functionality
                  golden-images  Running golden image tests
                  release        Release-related functionality
                  install        Helper to install specific versions of Ambient
                  join           Helper to join a server by various means
                  web            Web-related functionality
                  clean          Clean all build artifacts for all packages
                  run            Run a package. Alias for `package run`
                  serve          Serve a package. Alias for `package serve`
                  help           Print this message or the help of the given subcommand(s)

                Options:
                  -h, --help     Print help
                  -V, --version  Print version
              </code></pre>
            </div>
          </div>
          <aside class="notes">
            <p>
              Rust workspaces do a pretty good job of grouping together
              packages, but they don't support cross-toolchain packages (that
              is, mixing desktop and WASM), and they don't support nesting.
            </p>
            <p>
              rust-analyzer works with the workspace you have in the directory
              you've opened in your IDE. As a result, we had up to five VS Code
              windows open: the native client, web client, guest code, cloud
              services, and the website.
            </p>
            <p>
              To help with this, we used the `cargo-xtask` pattern. We built a
              tool in Rust in our root workspace, `campfire`, that could handle
              meta-development tasks like building all of the clients, updating
              package versions, deploying the packages, and more.
            </p>
            <p>
              This was then aliased using `cargo/config.toml` to make it easy to
              access. This was an upfront cost, but it paid for itself many
              times over, especially when building for multiple platforms.
            </p>
          </aside>
        </section>

        <!-- Full-width title slide -->
        <section>
          <h1 class="r-fit-text">So what went wrong?</h1>
          <aside class="notes">
            So now it's time to discuss the elephant in the room: what went
            wrong?
          </aside>
        </section>

        <!-- Code example slide -->
        <section>
          <h2>TOML isn't good for everything</h2>
          <pre><code style="font-size: 0.7em; text-wrap: balance; line-height: 1.2em;" class="language-toml" data-trim data-noescape>
[components]
height_offset = { type = "F32", name = "Nameplate Height Offset",
description = "The height offset from the base of this entity at which to render a nameplate. If not specified, it will default to this entity's local bounding AABB Z, and if that's not available, it will default to a constant.", attributes = [
    "Debuggable",
    "Networked",
] }

text_size = { type = "F32", name = "Nameplate Text Size", description = "The text size of the nameplate to render. If not specified, it will default to 2.0.", attributes = [
    "Debuggable",
    "Networked",
] }

hide = { type = "Empty", name = "Nameplate Hide", description = "If attached to a player, hide the nameplate for that player.", attributes = [
    "Networked",
    "Debuggable",
] }
          </code></pre>
          <p>
            <em>Not</em> comfy software:
            <a href="https://catgirl.ai/log/comfy-software/"
              >https://catgirl.ai/log/comfy-software/</a
            >
          </p>
          <aside class="notes">
            <p>
              Let's start with an easy one: our packages were defined with TOML.
              Unfortunately, TOML gets quite ugly for complex structures,
              especially because TOML 1.0 can't do multi-line literals. I wanted
              to do a domain-specific language for defining your schema, but
              there just wasn't enough time.
            </p>
            <p>
              It's ultimately a small thing, but every bit of friction is
              painful. A friend who tried out Ambient experienced genuine
              short-term burnout from this: the experience of constantly
              switching between TOML and Rust was deeply unpleasant.
            </p>
            <p>
              It wasn't "comfy software" - it made you feel worse for using it.
            </p>
          </aside>
        </section>

        <!-- Centered bullet points slide -->
        <section>
          <h2>Building your own engine is unwise</h2>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>Small team with limited resources</li>
              <li>Untouched parts of the engine</li>
              <li>Building an ecosystem is hard</li>
            </ul>
          </div>
          <aside class="notes">
            <p>
              If you've talked to any game developer, you'll have heard the
              standard advice: don't build your own engine.
            </p>

            <p>
              Rust solves many problems, but it doesn't solve that one. We were
              a small team with limited resources, and building an engine from
              scratch was a huge undertaking. We were able to innovate in ways
              that existing engines couldn't, but everything else suffered.
            </p>

            <p>
              There are parts of our engine that saw no love for months,
              sometimes years; for example, we had no audio on the web.
            </p>

            <p>
              On top of that, we were also building an ecosystem, which meant we
              were constantly updating the documentation, examples, platform,
              and more.
            </p>

            <p>Was it fun? Yes! Was it sustainable? Absolutely not.</p>

            <p>
              Looking back, I think we should have attempted to make Bevy work
              instead of building our own engine. That would have come with its
              own challenges, but it would have been a much more sustainable
              path, and we could both rely on and contribute to Bevy's growth.
            </p>
          </aside>
        </section>

        <!-- Two-column layout with text and code -->
        <section>
          <h2>Porting the runtime to the web</h2>
          <h3>Theory</h3>
          <div style="display: flex; align-items: top; height: 80%">
            <div style="flex: 0 0 60%">
              <p>Just make a new client with the same crates?</p>
              <p>
                WebAssembly / <code>wgpu</code> / <code>winit</code> dream team?
              </p>
              <p>Can it really be that simple?</p>
            </div>

            <div style="flex: 0 0 40%">
              <pre><code class="language-toml" style="font-size: 0.7em; white-space: pre-wrap; line-height: 1.2em;" data-trim data-noescape>
[package]
name = "ambient_web"
readme = "../README.md"
version.workspace = true
edition = "2021"
description = "Web client for ambient"
license = "MIT OR Apache-2.0"
repository = "https://github.com/AmbientRun/Ambient"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
ambient_app.workspace = true
ambient_audio.workspace = true
ambient_cameras.workspace = true
ambient_client_shared.workspace = true
ambient_core.workspace = true
ambient_debugger.workspace = true
ambient_ecs.workspace = true
              </code></pre>
            </div>
          </div>
          <aside class="notes">
            <p>
              But the biggest technical challenge we faced was porting the
              runtime to the web. We decided on web support after we'd already
              built the desktop client. Most other engines would struggle to
              survive this, but we had a secret weapon: Rust's native support
              for WebAssembly.
            </p>

            <p>
              As Ambient is modular, we created a new web client targeting
              wasm32-unknown-unknown, and progressively added Ambient's crates
              to it. We created a new client to ensure only the essentials were
              included, and to reduce the scope of any potential discrepancies.
            </p>

            <p>
              We believed that this would be straightforward. We had already
              built on top of `wgpu` and `winit`, which would abstract over
              platform specifics. It was not.
            </p>
          </aside>
        </section>

        <!-- Centered bullet points slide -->
        <section>
          <h2>Porting the runtime to the web</h2>
          <h3>Reality</h3>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>Different constraints</li>
              <li>Limited API support</li>
              <li>Performance discrepancies</li>
              <li>Debugging difficulties</li>
            </ul>
          </div>
          <aside class="notes">
            <p>
              The web is a different beast. It has different constraints,
              different APIs, and different performance characteristics. Many of
              the assumptions we'd made about the desktop didn't hold up on the
              web.
            </p>
            <p>
              Support for the latest APIs was *not* universal; Chrome was the
              only browser that supported everything we used, and it didn't
              support them on Linux.
            </p>
            <p>
              WebAssembly goes a long way towards shrinking the discrepancy in
              performance between web and desktop, but there was still a gap.
              Multithreading on the web was still very much a work in progress.
            </p>
            <p>
              Debugging was very difficult, especially with async code. The
              tooling for working with WASM was at least an order of magnitude
              worse than with native.
            </p>
          </aside>
        </section>

        <!-- Centered bullet points slide -->
        <section>
          <h2 style="margin-bottom: 0">Porting the runtime to the web</h2>
          <h3 style="margin-bottom: 0">System</h3>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <div style="flex: 0 0 70%">
              <ul
                style="
                  list-style: none;
                  padding: 0;
                  margin: 0;
                  line-height: 1.8;
                  text-align: center;
                "
              >
                <li><code>wasm32-unknown-unknown</code> is a lie</li>
                <li>Tokio doesn't fully work on the web</li>
                <li>
                  <code>wasm-bindgen</code> and <code>web-sys</code> for
                  <em>separate</em> system APIs
                </li>
                <li>Built our own system abstraction to deal with it</li>
                <li>
                  <code>cargo clippy</code> and <code>cargo deny</code> were
                  useful
                </li>
              </ul>
            </div>
            <div style="flex: 0 0 30%">
              <img src="media/ambient_sys.png" alt="ambient_sys docs" />
            </div>
          </div>
          <aside class="notes">
            <p>
              Let's be more specific. First, the platform itself:
              wasm32-unknown-unknown, the standard Rust target for WASM on the
              web, is a lie. Much of the standard library will panic at runtime,
              and many APIs are missing.
            </p>
            <p>
              Our existing code targeted Tokio, which has limited support for
              running on the web. Additionally, you don't control task
              scheduling on the web, unlike on desktop.
            </p>
            <p>
              You must use `wasm-bindgen` and `web-sys` to interact with the JS
              APIs and replace that missing functionality. We built our own
              system abstraction to cover the missing APIs, and used `clippy`
              and `cargo-deny` to help with the migration. Any calls we left
              behind would panic at runtime on the web.
            </p>
          </aside>
        </section>

        <!-- Centered comparison with logos -->
        <section>
          <h2>Porting the runtime to the web</h2>
          <h3>WebGPU</h3>
          <div
            style="
              display: flex;
              align-items: center;
              justify-content: center;
              height: 70%;
              gap: 1em;
            "
          >
            <img src="media/wgpu.png" alt="wgpu logo" style="height: 240px" />
            <div style="font-size: 3em">is not</div>
            <img
              src="media/webgpu.png"
              alt="WebGPU logo"
              style="height: 240px"
            />
          </div>
          <aside class="notes">
            <p>
              Next up, graphics. From the start, we used `wgpu`, which is a
              fantastic abstraction over the various graphics APIs, including
              WebGPU, and meant to serve as the WebGPU implementation for
              Firefox and others.
            </p>
            <p>
              We wanted support for relatively modern graphics, and we wanted to
              be able to use the same code on both the web and desktop.
            </p>
            <p>
              We were under the impression that using it would make porting to
              the web using WebGPU straightforward. It *did* make it easier,
              but, well, `wgpu` might be an implementation of WebGPU, but it is
              *not* WebGPU.
            </p>
            <p>
              The port we'd budgeted three weeks for ended up taking three
              months, and it didn't work for a sizeable fraction of our
              audience.
            </p>
          </aside>
        </section>

        <!-- Centered bullet points slide -->
        <section>
          <h2>Porting the runtime to the web</h2>
          <h3>WebGPU</h3>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>Bind group count</li>
              <li>Extensions</li>
              <li>Browser compatibility</li>
              <li>Spec interpretation</li>
              <li>Debugging</li>
              <li>Should have just used WebGL</li>
            </ul>
          </div>
          <aside class="notes">
            <p>
              Our renderer was designed around having many bind groups, which
              forced us to redesign it when we realised WebGPU only supports a
              few bind groups. We relied on extensions that aren't present on
              the web, which was expected, but still hurt.
            </p>
            <p>
              WebGPU support across browsers was basically limited to
              Windows/Mac Chrome; it is slightly better now, but only slightly.
              WebGPU is still off by default on both Linux and Firefox.
            </p>
            <p>
              Each browser has a slightly different interpretation of the spec,
              and their interpretation can differ from wgpu's native
              implementation, including in how they compile shaders.
            </p>
            <p>
              Debugging is very difficult - the standard tools don't work, and
              you're not debugging WebGPU, you're debugging your browser's
              implementation of WebGPU. Usual graphics debugging tools, like
              RenderDoc, work poorly with browsers. It's just not a very fun
              time.
            </p>
            <p>
              In hindsight, we should have just used WebGL. WebGPU wasn't there
              yet, and if you use Firefox or Linux, it still isn't.
            </p>
          </aside>
        </section>

        <!-- Centered text with networking info -->
        <section>
          <h2>Porting the runtime to the web</h2>
          <h3>WebTransport</h3>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>Networking with quinn, which implements QUIC</li>
              <li>QUIC is not quite WebTransport</li>
              <li>Underdeveloped ecosystem</li>
            </ul>
          </div>
          <aside class="notes">
            <p>
              For networking, we used the `quinn` library, which implements the
              QUIC protocol. QUIC is a fantastic protocol that provides secure
              reliable and unreliable data streams, which gave us a strong
              transport layer for our networking.
            </p>
            <p>
              WebTransport is a sibling protocol of QUIC that shares a great
              deal with it, and the majority of browsers have native client
              support for it. We assumed that having the web client use
              WebTransport to connect to the server would be straightforward.
            </p>
            <p>
              Unfortunately, despite being strongly related, WebTransport is a
              separate protocol from QUIC. There was no existing support for
              WebTransport on the server in Rust, so we worked with the
              open-source community to add WebTransport support to `h3`. This
              took a while.
            </p>
            <p>
              We also had to add support for the WebTransport API to our web
              client, but we were able to abstract over the differences between
              WebTransport and QUIC thanks to their shared ancestry.
            </p>
          </aside>
        </section>

        <!-- Centered bullet points slide -->
        <section>
          <h2>Porting the runtime to the web</h2>
          <h3>Performance</h3>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>
                Networking, rendering and logic all ran on the same thread!
              </li>
              <li>Messages dropped</li>
              <li>Scripting overhead</li>
            </ul>
          </div>
          <aside class="notes">
            <p>
              After all this, though, we discovered that networking, rendering
              and logic ran on the same thread on the web - remember, no
              multithreading - which meant that messages would be dropped if the
              client was too busy.
            </p>
            <p>
              Our WASM scripting had severe overhead in the web environment.
              This was catastrophic, and we added a few workarounds - including
              dropping frames to allow networking to catch up and experimenting
              with Web Workers.
            </p>
            <p>
              But we did not come up with a general solution, and the web
              client's experience very quickly degraded under load.
            </p>
          </aside>
        </section>

        <!-- Centered bullet points slide -->
        <section>
          <h2>Using WebAssembly for Scripting</h2>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
              gap: 1em;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: right;
              "
            >
              <li>Game engines usually use Lua or such</li>
              <li>But how do you support many languages?</li>
              <li>Let’s try</li>
            </ul>

            <img
              src="media/wasm.png"
              alt="WebAssembly logo"
              style="height: 240px"
            />
          </div>
          <aside class="notes">
            <p>
              Let's talk about scripting. I've built my fair share of scriptable
              applications, and I've typically done this with Lua or other
              languages amenable to embedding.
            </p>
            <p>
              A problem that I've always encountered while doing so, however, is
              that you're locked into whatever language you've embedded. The
              only way to add more languages was to add more interpreters.
            </p>
            <p>
              This time around, we decided to use WebAssembly for scripting,
              which is a language-independent bytecode format. Despite what the
              name suggests, it can be used outside of the web!
            </p>
            <p>
              In theory, we could use any language that compiles to WebAssembly,
              and we could have Rust as a first-class guest language. In
              practice, the story is not so simple.
            </p>
          </aside>
        </section>

        <!-- Centered bullet points slide -->
        <section>
          <h2>Using WebAssembly for Scripting</h2>
          <h3>How?</h3>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
              gap: 1em;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>On the web, "just" use the browser</li>
              <li>On native, you need a runtime: <code>wasmtime</code>.</li>
              <li>How do you bind host code?</li>
            </ul>
          </div>
          <aside class="notes">
            <p>
              First problem, how do you actually run WebAssembly? On the web,
              you can just use the browser's WebAssembly runtime - at least in
              theory - but we needed a way to run it natively.
            </p>
            <p>
              There are a couple of interpreters, but we chose the Bytecode
              Alliance's Wasmtime for this as it had a JIT compiler, natively
              supported Rust as a host, and was at the forefront of WASM
              development.
            </p>
            <p>
              In doing so, however, we discovered our second problem: how do you
              bind Rust types to WebAssembly, which only has a C-like ABI?
            </p>
          </aside>
        </section>

        <!-- Two-column layout with text and code -->
        <section>
          <h2>Using WebAssembly for Scripting</h2>
          <h3>wit-bindgen</h3>
          <div
            style="display: flex; align-items: center; height: 80%; gap: 32px"
          >
            <div style="flex: 0 0 30%">
              <div
                style="
                  display: flex;
                  flex-direction: column;
                  font-size: 0.8em;
                  padding: 0;
                  margin: 0;
                  line-height: 1.3;
                  text-align: right;
                  gap: 0.5em;
                "
              >
                <div>
                  <code>wit-bindgen</code> to the rescue! well, <em>sort of</em>
                </div>
                <div>WIT only supported so much</div>
                <div>Still needed glue code</div>
                <div>Only a few languages supported</div>
              </div>
            </div>
            <div style="flex: 0 0 35%">
              <pre><code class="language-wit" style="font-size: 0.7em; white-space: pre-wrap; line-height: 1.2em;" data-trim data-noescape>
interface entity {
  use types.{entity-id, vec3, quat, mat4}
  use component.{entity as entity-data}

  spawn: func(data: entity-data) -&gt; entity-id
  despawn: func(entity: entity-id) -&gt; option&lt;entity-data&gt;
  in-area: func(position: vec3, radius: float32) -&gt; list&lt;entity-id&gt;

  exists: func(entity: entity-id) -&gt; bool
  get-all: func(index: u32) -&gt; list&lt;entity-id&gt;
  resources: func() -&gt; entity-id
  synchronized-resources: func() -&gt; entity-id
  persisted-resources: func() -&gt; entity-id
}
              </code></pre>
            </div>
            <div style="flex: 0 0 35%">
              <pre><code class="language-rust" style="font-size: 0.7em; white-space: pre-wrap; line-height: 1.2em;" data-trim data-noescape>
                // Rust implementation of the WIT interface
                pub fn exists(entity: EntityId) -&gt; bool {
                    wit::entity::exists(entity.into_bindgen())
                }

                /// Gets all of the entities that have the given &grave;component&grave;.
                pub fn get_all&lt;T&gt;(component: Component&lt;T&gt;) -&gt; Vec&lt;EntityId&gt; {
                    wit::entity::get_all(component.index()).from_bindgen()
                }

                /// Gets all of the entities within &grave;radius&grave; of &grave;position&grave;.
                pub fn in_area(position: Vec3, radius: f32) -&gt; Vec&lt;EntityId&gt; {
                    wit::entity::in_area(position.into_bindgen(), radius).from_bindgen()
                }
              </code></pre>
            </div>
          </div>
          <aside class="notes">
            <p>
              Luckily, the Bytecode Alliance had a solution for this:
              wit-bindgen. Unluckily, it was still in development when we picked
              it up, and we discovered that it was part of the greater Component
              Model proposal, which was still being designed. This meant that we
              were following a changing implementation and spec, which led to
              churn on our part.
            </p>
            <p>
              The interface is specified in WIT, which is an interface
              definition language for the Component Model, which you can see an
              example of here. It supports a subset of what Rust supports, which
              meant we had to be careful in how we designed our API.
            </p>
            <p>
              Unfortunately, the generated WIT code wasn't ergonomic, so we
              still had to write our own glue code for the guest API. Because of
              this, we were effectively stuck with a Rust guest, despite
              ostensibly being able to use any language with WASM.
            </p>
            <p>
              In addition, wit-bindgen's language support was limited; even if
              everything worked out, we wouldn't support that many more
              languages, and none of them would have been scripting languages.
            </p>
            <p>
              In hindsight, we should have considered writing our own binding
              layer - WIT is great, and I wish the best for it, but it wasn't
              the right fit for our constraints.
            </p>
          </aside>
        </section>

        <!-- Centered bullet points slide -->
        <section>
          <h2>Using WebAssembly for Scripting</h2>
          <h3>WebAssembly System Interface</h3>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: right;
              "
            >
              <li>
                <code>wasm32-wasi</code> (now <code>wasm32-wasip1</code>) is
                less of a lie!
              </li>
              <li>We can use it for guest code 😀</li>
              <li>but it still needs implementation… 😭</li>
              <li><code>preview1</code> ≠ <code>preview2</code></li>
            </ul>
          </div>
          <aside class="notes">
            <p>
              Earlier, I mentioned that wasm32-unknown-unknown doesn't implement
              any system interfaces. Luckily, that's less of a problem for our
              guest code; we could use wasm32-wasi, powered by the WebAssembly
              System Interface.
            </p>
            <p>
              Our engine - the host - can then implement the host side of the
              interface, so that the guest can use these APIs without a care in
              the world.
            </p>
            <p>
              Rust supports the first preview of preview of WASI, but our use of
              the Component Model forced us onto the second preview, which was
              still in development. This meant we had to use an adapter, and
              have our own custom implementation of the WASI APIs.
            </p>
            <p>
              The APIs were frequently changing, leading to more churn for us.
            </p>
          </aside>
        </section>

        <!-- Single line slide with headers -->
        <section>
          <h2>Using WebAssembly for Scripting</h2>
          <h3>On the web</h3>
          <p>Use the browser's runtime?</p>
          <p><code>wasm-bridge</code> to the rescue!</p>
          <p>But what cost are we paying?</p>
          <p>d-d-double-FFI!</p>
          <aside class="notes">
            <p>
              After a lot of work, we did eventually get desktop scripting
              working reasonably well. The next challenge was to get it working
              on the web. We could just use the browser's runtime, right?
            </p>
            <p>
              Unfortunately, our guest code uses wasm32-wasi and the Component
              Model, neither of which were supported on the web. This meant we
              had to write a web backend for our scripting, and then wire that
              backend up to the Component Model.
            </p>
            <p>
              Web support for the Component Model is coming, but wasn't ready
              when we needed it. Luckily, we could use the open-source
              `wasm-bridge` for this. We adapted it to run our guest code on the
              web.
            </p>
            <p>
              However... wasm-bridge uses a tool called JCO to convert a
              WebAssembly component to JS module, and then wraps a Rust
              interface around that JS module. Because Ambient was *also*
              running as a JS-wrapped WASM module, we were paying the FFI cost
              multiple times over.
            </p>
            <p>
              This was the main cause of our performance issues on the web. We
              were unable to fix this in time, as it was baked into how Ambient
              on the runtime was implemented.
            </p>
          </aside>
        </section>

        <!-- Centered bullet points slide -->
        <section>
          <h2>Using WebAssembly for Scripting</h2>
          <h3>Other issues</h3>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>Debugging sucks</li>
              <li>Module compile time is slow</li>
              <li>No ability to interpret</li>
              <li>Separate memory space means copies</li>
              <li>Other languages never happened</li>
            </ul>
          </div>
          <aside class="notes">
            <p>
              There were other issues we encountered with WebAssembly. Debugging
              is difficult. It's theoretically possible - we had it working
              outside of Ambient - but we couldn't get it working inside,
              forcing you to use print debugging.
            </p>
            <p>
              Wasmtime compiles modules as it loads them, which takes time. With
              many modules, it can stall startup for many seconds, as you saw in
              the demo. There was no way to quickly interpret code, which meant
              modules *had* to be compiled.
            </p>
            <p>
              Because WASM has its own memory space for security reasons, we had
              to constantly copy data between the host and guest, which is
              expensive and slow, especially for an ECS with significant
              traffic.
            </p>
            <p>
              Finally, we never got around to trying out other languages, which
              meant there was ultimately no point in using WebAssembly.
            </p>
          </aside>
        </section>

        <!-- Centered bullet points slide -->
        <section>
          <h2>Using WebAssembly for Scripting</h2>
          <h3>Conclusion</h3>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>
                There’s certainly promise, but... there are also major problems.
              </li>
              <li>Just use a conventional scripting language.</li>
            </ul>
          </div>
          <aside class="notes">
            <p>
              In conclusion: WebAssembly showed promise for this use case, but
              like WebGPU, the pieces still need to come together. You can't run
              many scripting-relevant languages on it, binding is difficult and
              slow at runtime, and supporting both desktop and web is very
              challenging.
            </p>
            <p>
              All of the other projects I'm aware of that used WASM for
              scripting are either dead or have moved away from it.
            </p>
            <p>
              All things considered, I'd recommend a conventional scripting
              language like Lua, Ruby or Python - especially as all of those now
              have Rust implementations! I'm personally curious about using C#
              as a scripting language myself.
            </p>
          </aside>
        </section>

        <!-- Centered bullet point slide -->
        <section>
          <h2>The packages dream</h2>
          <ul
            style="
              list-style: none;
              padding: 0;
              margin: 0;
              line-height: 1.8;
              text-align: center;
            "
          >
            <li>Flexibility, robustness, dynamic composability?</li>
            <li>Easier said than done</li>
            <li>Get it working, then make it good?</li>
            <li>Maybe Verse will crack it</li>
          </ul>
          <aside class="notes">
            <p>
              We wanted to make all of our packages naturally interoperate, so
              that anyone could mod any game. Unfortunately, this is still an
              active research problem: it is very difficult to have all of these
              disparate packages from disparate authors function together as a
              cohesive whole, especially without any prior coordination. It
              needed a lot more time in the oven.
            </p>
            <p>
              I think this problem is fascinating, but cracking it requires
              significant R&D beyond what we had available: my hope was that we
              could rely on "worse is better", ship a v1, and then iterate on it
              to get to a better place. We didn't get there, obviously.
            </p>
            <p>
              I think Unreal Engine's Verse language is the most substantive
              effort at solving this, but right now it's the Fortnite scripting
              language, so I guess we'll have to wait a few more years to find
              out.
            </p>
          </aside>
        </section>

        <!-- Single line title slide -->
        <section>
          <h1 class="r-fit-text">Dioxus/Rust in 2023. <em>Hmm.</em></h1>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>It wasn't great.</li>
              <li>Broken formatting. Constant clones. Slow iteration.</li>
              <li>Not their fault, but...</li>
            </ul>
          </div>
          <aside class="notes">
            <p>
              We used Dioxus, a full-stack Rust web framework, for the Ambient
              platform. This was in 2023, so I know it's gotten better now - a
              lot of the pain points we ran into are gone, thanks to clever
              tricks and engineering - but it was very much not the right tool
              for the job.
            </p>
            <p>
              We loved using Rust, but frontend development is all about
              iteration, and Rust in Dioxus in 2023 was not germane to that. It
              was a painful experience, with broken formatting, clones all over
              the place, and a very clearly WIP developer experience.
            </p>
            <p>
              No fault to them - they were doing their best, and it was on us
              for jumping on too early, but we were very, very glad to be using
              a standard TypeScript workflow after Ambient.
            </p>
          </aside>
        </section>

        <!-- Single line title slide -->
        <section>
          <h1 class="r-fit-text">No editor, no creation</h1>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>Dims editor removed, but never replaced</li>
              <li>Higher barrier to entry, poor DX, less fun</li>
              <li>Modding not as easy</li>
            </ul>
          </div>
          <aside class="notes">
            <p>
              Dims had a multiplayer, concurrent editor, which made it possible
              to create content together without code. We removed this as part
              of our open-source move, with the intention of adding it back as a
              package, but we never had the time to get it done.
            </p>
            <p>
              This is one of my bigger regrets: I think an editor is key to game
              engine adoption, especially when you're on the backfoot, and our
              not having one raised the barrier to entry and made the time to
              fun engagement higher.
            </p>
            <p>
              I should have been able to create a level for Tangent without
              having to specify my level in code like it's the 70s. This is
              something Bevy also struggles with to some extent, but they're
              making moves towards fixing it.
            </p>
          </aside>
        </section>

        <!-- Centered bullet points slide -->
        <section>
          <h2 class="r-fit-text">Networking without prediction</h2>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>Inherited Dims' networking stack</li>
              <li>Optimised for developer experience, not performance</li>
              <li>Zero prediction, zero interpolation, <em>zero leeway</em></li>
            </ul>
          </div>
          <aside class="notes">
            <p>
              In Dims, we chose not to use prediction or rollback, as we assumed
              that most users would work together in small,
              geographically-colocated groups. I wasn't sure about this at the
              time, but it worked well enough for Dims.
            </p>
            <p>
              The problem is that we carried this over into Ambient, where that
              assumption no longer held, and we did not update for it. We
              optimised for developer experience first - both ours and package
              makers - which meant we wanted to ignore the complications of
              real-world networking. Our synchronization primarily relied on
              sending ECS component diffs directly between server and client, a
              method that offers simplicity but is highly sensitive to network
              latency, leading to visual inconsistencies and lag when delays
              occur. Unfortunately, this came back to bite us, and it's not a
              trivial thing to retrofit.
            </p>
            <p>
              We attempted to work around this by allocating cloud servers near
              users, but this was both expensive and not useful for people
              playing across continents; one of our team members was based in
              Canada, and it was obvious that there was already a problem, but
              we didn't have the time to fix it.
            </p>
          </aside>
        </section>

        <!-- Single line title slide -->
        <section>
          <h1 class="r-fit-text">Our biggest issue</h1>
          <aside class="notes">
            <p>
              Finally, our biggest issue... was that people just weren’t
              interested. We did not find product-market fit. We built a lot of
              cool tech, but we couldn’t get people to care. I believe that with
              enough time, we could have made this work, but when you take VC
              funding, you're expected to deliver.
            </p>
            <p>
              After this, we experimented with AI-enhanced gamedev under the
              Braindump banner, but that's a story for another talk.
            </p>
          </aside>
        </section>

        <!-- Centered bullet points slide -->
        <section>
          <h2>What did we learn?</h2>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              height: 80%;
            "
          >
            <ul
              style="
                list-style: none;
                padding: 0;
                margin: 0;
                line-height: 1.8;
                text-align: center;
              "
            >
              <li>
                Rust was the right language for this, but “this” was wrong
              </li>
              <li>
                Use existing projects as much as possible; avoid wheel
                reinvention
              </li>
              <li>Implement web support from day one</li>
              <li>Use mature technologies</li>
              <li>Use conventional scripting</li>
              <li>Spend "novelty budget" well</li>
              <li>Build things people want</li>
            </ul>
          </div>
          <aside class="notes">
            <p>
              So, what did we learn from all of this? We were confident that
              Rust was the right choice for the engine. We just didn't know what
              we wanted to build.
            </p>
            <p>
              By the time Ambient was born, Bevy was closer to what we needed.
              We should have investigated how hard it would have been to switch
              to it.
            </p>
            <p>
              We tried to retroactively add web support, but this should have
              been a core part of the engine from the beginning. At a minimum,
              we should have gone with a more conventional scripting language
              and WebGL over WebAssembly and WebGPU. These are fantastic
              technologies, but they're just not ready yet.
            </p>
            <p>
              We shouldn't have tried to use Rust for *everything*, especially
              not the website. Fundamentally, we had a finite "novelty budget",
              and we should have spent it better. Going all-in on Dioxus,
              WebGPU, WASM, and WebTransport was simply too much. Focusing our
              novelty on just one or two core areas might have been more
              sustainable.
            </p>
            <p>
              Finally, we needed to meet people where they were. We built all of
              this cool technology, but we couldn't convince people to use it.
              We needed to talk to users first and solve the problems they had,
              not the problems we thought they had.
            </p>
          </aside>
        </section>

        <!-- Conclusion slide -->
        <section>
          <h2>Conclusion and Q&A</h2>
          <p>
            <a href="https://github.com/AmbientRun/Ambient"
              >https://github.com/AmbientRun/Ambient</a
            >
          </p>
          <div
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              width: 100%;
              gap: 32px;
            "
          >
            <div
              style="
                display: flex;
                align-items: center;
                flex: 1;
                justify-content: flex-end;
              "
            >
              <img
                src="media/philpax.png"
                alt="Philpax avatar"
                style="max-width: 240px"
              />
            </div>
            <div style="flex: 1; text-align: left">
              <p>Mithun Hunsur</p>
              <p><em>@</em><a href="https://philpax.me">philpax.me</a></p>
            </div>
          </div>
          <aside class="notes">
            <p>
              Thanks for listening! I still believe in the fundamental dream
              that Ambient represents - an open-source multiplayer-first game
              engine designed for shared creation - but our time with the
              concept is over.
            </p>
            <p>
              If you're curious, you can find the Ambient repo at the link
              above, but it hasn't been updated since 2023, and many of the
              associated services are now down.
            </p>
            <p>You can find me on Bluesky at @philpax.me (also my website!)</p>
            <p>
              I'll take questions now, but I'll be around if you'd like to talk
              more.
            </p>
          </aside>
        </section>
      </div>
    </div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
